#nullable enable

using Valour.Server.Database;
using Valour.Shared;
using Valour.Shared.Authorization;
using Valour.Shared.Models;

namespace Valour.Server.Services;

public class ChannelService
{
    private readonly ValourDb _db;
    private readonly PlanetMemberService _memberService;
    private readonly ILogger<ChannelService> _logger;
    private readonly CoreHubService _coreHub;
    private readonly PlanetPermissionService _planetPermissionService;
    private readonly HostedPlanetService _hostedPlanetService;

    public ChannelService(
        ValourDb db,
        PlanetMemberService memberService,
        CoreHubService coreHubService,
        ILogger<ChannelService> logger,
        PlanetPermissionService planetPermissionService, 
        HostedPlanetService hostedPlanetService)
    {
        _db = db;
        _memberService = memberService;
        _logger = logger;
        _coreHub = coreHubService;
        _planetPermissionService = planetPermissionService;
        _hostedPlanetService = hostedPlanetService;
    }

    private static bool IsPlanetCallChannelType(ChannelTypeEnum type) =>
        ISharedChannel.IsPlanetCallType(type);

    private static PermissionState GetNodePermissionState(PermissionsNode node, Permission permission) =>
        ISharedPermissionsNode.GetPermissionState(node, permission, ignoreviewperm: true);

    private static List<PermissionsNode> BuildAssociatedChatPermissionNodes(
        List<PermissionsNode>? sourceNodes,
        long planetId,
        long callChannelId,
        long chatChannelId)
    {
        var result = new List<PermissionsNode>();
        if (sourceNodes is null || sourceNodes.Count == 0)
            return result;

        foreach (var sourceNode in sourceNodes)
        {
            if (sourceNode.TargetId != callChannelId)
                continue;

            if (sourceNode.TargetType is not ChannelTypeEnum.PlanetVoice and not ChannelTypeEnum.PlanetVideo)
                continue;

            var mappedNode = new PermissionsNode
            {
                Id = IdManager.Generate(),
                PlanetId = planetId,
                RoleId = sourceNode.RoleId,
                TargetId = chatChannelId,
                TargetType = ChannelTypeEnum.PlanetChat,
                Code = 0,
                Mask = 0
            };

            var viewState = GetNodePermissionState(sourceNode, VoiceChannelPermissions.View);
            if (viewState != PermissionState.Undefined)
            {
                mappedNode.SetPermission(ChatChannelPermissions.View, viewState);
                mappedNode.SetPermission(ChatChannelPermissions.ViewMessages, viewState);
                mappedNode.SetPermission(ChatChannelPermissions.PostMessages, viewState);
            }

            var manageChannelState = GetNodePermissionState(sourceNode, VoiceChannelPermissions.ManageChannel);
            if (manageChannelState != PermissionState.Undefined)
                mappedNode.SetPermission(ChatChannelPermissions.ManageChannel, manageChannelState);

            var managePermissionsState = GetNodePermissionState(sourceNode, VoiceChannelPermissions.ManagePermissions);
            if (managePermissionsState != PermissionState.Undefined)
                mappedNode.SetPermission(ChatChannelPermissions.ManagePermissions, managePermissionsState);

            if (mappedNode.Mask != 0)
                result.Add(mappedNode);
        }

        return result;
    }

    /// <summary>
    /// Returns the channel with the given id
    /// </summary>
    public async ValueTask<Channel?> GetChannelAsync(long? planetId, long channelId)
    {
        if (planetId is not null)
        {
            var hostedPlanet = await _hostedPlanetService.GetRequiredAsync(planetId.Value);
            var channel = hostedPlanet.GetChannel(channelId);
            return channel;
        }
        else
        {
            var channel = await _db.Channels.FindAsync(channelId);
            if (channel is null)
                return null;
            
            // Require planet up front
            if (channel.PlanetId is not null)
                return null;
        
            return channel?.ToModel();
        }
    }

    /// <summary>
    /// Given two user ids, returns the direct chat channel between them
    /// </summary>
    public async ValueTask<Channel?> GetDirectChannelByUsersAsync(long userOneId, long userTwoId, bool create = true)
    {
        var channel = await _db.Channels
            .AsNoTracking()
            .Include(x => x.Members)
            .Where(x => x.ChannelType == ChannelTypeEnum.DirectChat)
            .Where(x => x.Members.Any(m => m.UserId == userOneId) &&
                        x.Members.Any(m => m.UserId == userTwoId))
            .FirstOrDefaultAsync();

        // If there is no channel and we have this set to create it if missing...
        if (channel is null && create)
        {
            var newId = IdManager.Generate();
            
            // Create channel
            channel = new Valour.Database.Channel()
            {
                Id = newId,

                // Build the members
                Members = [
                    new()
                    {
                        Id = IdManager.Generate(),
                        ChannelId = newId,
                        UserId = userOneId
                    },
                    new()
                    {
                        Id = IdManager.Generate(),
                        ChannelId = newId,
                        UserId = userTwoId
                    }
                ],

                Name = "Direct Chat",
                Description = "A private discussion",
                ChannelType = ChannelTypeEnum.DirectChat,
                LastUpdateTime = DateTime.UtcNow,
                IsDeleted = false,
                
                RawPosition = 0,
                InheritsPerms = false,
                IsDefault = false,

                // These are null and technically we don't have to show this
                // but I am showing it so you know it SHOULD be null!
                PlanetId = null,
                ParentId = null,
                
                Version = ISharedChannel.CurrentVersion,
            };
            
            await _db.Channels.AddAsync(channel);
            await _db.SaveChangesAsync();
        }
        
        return channel?.ToModel();
    }

    /// <summary>
    /// Returns all the direct chat channels for the given user id
    /// </summary>
    public Task<List<Channel>> GetAllDirectAsync(long userId)
    {
        return _db.Channels.Include(x => x.Members)
            .Where(x => x.ChannelType == ChannelTypeEnum.DirectChat &&
                        x.Members.Any(m => m.UserId == userId))
            .Select(x => x.ToModel())
            .ToListAsync();
    }
    
    /// <summary>
    /// Soft deletes the given planet channel
    /// </summary>
    public async Task<TaskResult> DeletePlanetChannelAsync(long planetId, long channelId)
    {
        var hostedPlanet = await _hostedPlanetService.GetRequiredAsync(planetId);

        var isAssociatedChat = await _db.Channels
            .AnyAsync(x => x.AssociatedChatChannelId == channelId && !x.IsDeleted);
        if (isAssociatedChat)
            return TaskResult.FromFailure("This channel is managed by an associated call channel and cannot be deleted directly.");
        
        var dbChannel = await _db.Channels.FindAsync(channelId);
        if (dbChannel is null)
            return TaskResult.FromFailure( "Channel not found.");
        
        if (dbChannel.PlanetId != planetId)
            return TaskResult.FromFailure( "Channel does not belong to planet.");
        
        if (dbChannel.IsDefault == true)
            return TaskResult.FromFailure("You cannot delete the default channel.");

        var channelsToDelete = new List<Valour.Database.Channel> { dbChannel };

        if (dbChannel.AssociatedChatChannelId is not null)
        {
            var associated = await _db.Channels.FirstOrDefaultAsync(x =>
                x.Id == dbChannel.AssociatedChatChannelId.Value &&
                x.PlanetId == planetId &&
                !x.IsDeleted);

            if (associated is not null)
                channelsToDelete.Add(associated);
        }

        foreach (var channelToDelete in channelsToDelete)
        {
            channelToDelete.IsDeleted = true;
            _db.Channels.Update(channelToDelete);
        }

        await _db.SaveChangesAsync();

        foreach (var channelToDelete in channelsToDelete)
        {
            hostedPlanet.RemoveChannel(channelToDelete.Id);
        }

        // Channel topology changed; clear cached channel access snapshots.
        await _planetPermissionService.HandleChannelTopologyChange(planetId);

        foreach (var channelToDelete in channelsToDelete)
        {
            var model = channelToDelete.ToModel();
            if (model.PlanetId is not null)
                _coreHub.NotifyPlanetItemDelete(model.PlanetId.Value, model);
        }
        
        return TaskResult.SuccessResult;
    }
    
    /// <summary>
    /// Creates the given channel
    /// </summary>
    public async Task<TaskResult<Channel>> CreateAsync(Channel channel, List<PermissionsNode> nodes = null)
    {
        var baseValid = await ValidateChannel(channel);
        if (!baseValid.Success)
            return new(false, baseValid.Message);

        if (ISharedChannel.PlanetChannelTypes.Contains(channel.ChannelType))
        {
            if (channel.PlanetId is null)
            {
                return TaskResult<Channel>.FromFailure("PlanetId is required for planet channels.");
            }
        }
        
        HostedPlanet? hostedPlanet = null;

        // Only planet channels have permission nodes
        if (channel.PlanetId is not null)
        {
            hostedPlanet = await _hostedPlanetService.GetRequiredAsync(channel.PlanetId.Value);
            
            // Handle bundled permissions
            if (nodes is not null && nodes.Count > 0)
            {
                foreach (var node in nodes)
                {
                    if (node.TargetId != channel.Id)
                        return TaskResult<Channel>.FromFailure("Node target id does not match channel id");
                
                    if (node.PlanetId != channel.PlanetId)
                        return TaskResult<Channel>.FromFailure("Node planet id does not match channel planet id");
                    
                    node.Id = IdManager.Generate();
                }
            }
        }
        else
        {
            if (channel.ParentId is not null)
            {
                return TaskResult<Channel>.FromFailure("Only planet channels can have a parent.");
            }
        }

        channel.Id = IdManager.Generate();
        channel.LastUpdateTime = DateTime.UtcNow;

        Channel? associatedChatChannel = null;
        if (channel.PlanetId is not null && IsPlanetCallChannelType(channel.ChannelType))
        {
            associatedChatChannel = new Channel
            {
                Id = IdManager.Generate(),
                Name = channel.Name,
                Description = $"Integrated chat for {channel.Name}",
                ChannelType = ChannelTypeEnum.PlanetChat,
                LastUpdateTime = channel.LastUpdateTime,
                PlanetId = channel.PlanetId,
                ParentId = channel.ParentId,
                RawPosition = 0,
                InheritsPerms = channel.InheritsPerms,
                IsDefault = false,
                Nsfw = channel.Nsfw
            };

            channel.AssociatedChatChannelId = associatedChatChannel.Id;
        }

        await using var tran = await _db.Database.BeginTransactionAsync();

        try
        {
            await _db.Channels.AddAsync(channel.ToDatabase());
            await _db.SaveChangesAsync();
            
            // Only add nodes if necessary
            if (nodes is not null)
            {
                foreach (var node in nodes)
                {
                    node.TargetId = channel.Id;
                }
                
                await _db.PermissionsNodes.AddRangeAsync(nodes.Select(x => x.ToDatabase()));
                await _db.SaveChangesAsync();
            }

            if (associatedChatChannel is not null)
            {
                var chatValidation = await ValidateChannel(associatedChatChannel);
                if (!chatValidation.Success)
                {
                    await tran.RollbackAsync();
                    return TaskResult<Channel>.FromFailure(chatValidation.Message);
                }

                await _db.Channels.AddAsync(associatedChatChannel.ToDatabase());
                await _db.SaveChangesAsync();

                var mappedChatNodes = BuildAssociatedChatPermissionNodes(
                    nodes,
                    channel.PlanetId!.Value,
                    channel.Id,
                    associatedChatChannel.Id);

                if (mappedChatNodes.Count > 0)
                {
                    await _db.PermissionsNodes.AddRangeAsync(mappedChatNodes.Select(x => x.ToDatabase()));
                    await _db.SaveChangesAsync();
                }
            }

            await tran.CommitAsync();
        }
        catch (Exception e)
        {
            _logger.LogError(e, "Failed to create planet chat channel");
            await tran.RollbackAsync();
            return TaskResult<Channel>.FromFailure("Failed to create channel");
        }

        if (hostedPlanet is not null)
        {
            hostedPlanet.UpsertChannel(channel);
            if (associatedChatChannel is not null)
            {
                hostedPlanet.UpsertChannel(associatedChatChannel);
                _coreHub.NotifyPlanetItemChange(channel.PlanetId!.Value, associatedChatChannel);
            }
            await _planetPermissionService.HandleChannelTopologyChange(channel.PlanetId!.Value);
            _coreHub.NotifyPlanetItemChange(channel.PlanetId!.Value, channel);
        }

        return TaskResult<Channel>.FromData(channel);
    }
    
    /// <summary>
    /// Updates the given channel
    /// </summary>
    public async Task<TaskResult<Channel>> UpdateAsync(Channel updated)
    {
        var old = await _db.Channels.FindAsync(updated.Id);
        if (old is null) 
            return TaskResult<Channel>.FromFailure("Channel not found");
        
        // Update-specific validation
        if (old.Id != updated.Id)
            return TaskResult<Channel>.FromFailure("Cannot change Id.");
        
        if (old.PlanetId != updated.PlanetId)
            return TaskResult<Channel>.FromFailure("Cannot change PlanetId.");
        
        if (old.ChannelType != updated.ChannelType)
            return TaskResult<Channel>.FromFailure("Cannot change ChannelType.");
        
        if (old.AssociatedChatChannelId != updated.AssociatedChatChannelId)
            return TaskResult<Channel>.FromFailure("Cannot change AssociatedChatChannelId.");

        // Channel parent is being changed
        if (old.ParentId != updated.ParentId)
        {
            return TaskResult<Channel>.FromFailure("Use move channel endpoint to change parent.");
        }
        // Channel is being moved
        if (old.RawPosition != updated.RawPosition)
        {
            return TaskResult<Channel>.FromFailure("Use move channel endpoint to change position.");
        }
        
        // Basic validation
        var baseValid = await ValidateChannel(updated);
        if (!baseValid.Success)
            return TaskResult<Channel>.FromFailure(baseValid.Message);

        HostedPlanet? hostedPlanet = null;
        if (updated.PlanetId is not null)
        {
            hostedPlanet = await _hostedPlanetService.GetRequiredAsync(updated.PlanetId.Value);
        }

        var trans = await _db.Database.BeginTransactionAsync();
        
        // Update
        try
        {
            _db.Entry(old).CurrentValues.SetValues(updated);
            await _db.SaveChangesAsync();

            await trans.CommitAsync();
        }
        catch (System.Exception e)
        {
            await trans.RollbackAsync();
            _logger.LogError("{Time}:{Error}", DateTime.UtcNow.ToShortTimeString(), e.Message);
            return new(false, e.Message);
        }

        if (hostedPlanet is not null)
        {
            hostedPlanet.UpsertChannel(updated);
            await _planetPermissionService.HandleChannelTopologyChange(updated.PlanetId!.Value);
            _coreHub.NotifyPlanetItemChange(updated.PlanetId!.Value, updated);
        }

        // Response
        return TaskResult<Channel>.FromData(updated);
    }

    /// <summary>
    /// Sets the primary (default) channel for a planet
    /// </summary>
    public async Task<TaskResult> SetPrimaryChannelAsync(long planetId, long channelId)
    {
        var hostedPlanet = await _hostedPlanetService.GetRequiredAsync(planetId);
        var oldDefault = hostedPlanet.GetDefaultChannel();

        if (oldDefault?.Id == channelId)
            return TaskResult.SuccessResult;

        var newDefault = hostedPlanet.GetChannel(channelId);
        if (newDefault is null)
            return new TaskResult(false, "Channel not found.");

        if (newDefault.ChannelType != ChannelTypeEnum.PlanetChat)
            return new TaskResult(false, "Primary channel must be a chat channel.");

        if (newDefault.PlanetId != planetId)
            return new TaskResult(false, "Channel does not belong to this planet.");

        var trans = await _db.Database.BeginTransactionAsync();
        try
        {
            if (oldDefault is not null)
            {
                var oldDb = await _db.Channels.FindAsync(oldDefault.Id);
                if (oldDb is not null)
                {
                    oldDb.IsDefault = false;
                    await _db.SaveChangesAsync();
                }
            }

            var newDb = await _db.Channels.FindAsync(channelId);
            if (newDb is null)
            {
                await trans.RollbackAsync();
                return new TaskResult(false, "Channel not found in database.");
            }

            newDb.IsDefault = true;
            await _db.SaveChangesAsync();
            await trans.CommitAsync();
        }
        catch (Exception e)
        {
            await trans.RollbackAsync();
            _logger.LogError("{Time}:{Error}", DateTime.UtcNow.ToShortTimeString(), e.Message);
            return new TaskResult(false, e.Message);
        }

        // Update cache and broadcast
        if (oldDefault is not null)
        {
            oldDefault.IsDefault = false;
            hostedPlanet.UpsertChannel(oldDefault);
            _coreHub.NotifyPlanetItemChange(planetId, oldDefault);
        }

        newDefault.IsDefault = true;
        hostedPlanet.UpsertChannel(newDefault);
        _coreHub.NotifyPlanetItemChange(planetId, newDefault);

        return TaskResult.SuccessResult;
    }

    /// <summary>
    /// Returns the number of children for the given channel id
    /// </summary>
    public Task<int> GetChildCountAsync(long id) =>
        _db.Channels.CountAsync(x => x.ParentId == id);

    /// <summary>
    /// Returns the ids of all of the children of the given channel id
    /// </summary>
    public Task<List<long>> GetChildrenIdsAsync(long id) =>
        _db.Channels.Where(x => x.ParentId == id)
            .Select(x => x.Id)
            .ToListAsync();
    
    /// <summary>
    /// Returns if the given category id is the last remaining category
    /// in its planet (used to prevent deletion of the last category)
    /// </summary>
    public async Task<bool> IsLastCategory(long categoryId)
    {
        var category = await _db.Channels
            .Where(x => x.Id == categoryId && x.ChannelType == ChannelTypeEnum.PlanetCategory)
            .Select(x => new { x.PlanetId })
            .FirstOrDefaultAsync();

        if (category?.PlanetId is null)
            return false;

        return await _db.Channels.CountAsync(x =>
            x.PlanetId == category.PlanetId &&
            x.ChannelType == ChannelTypeEnum.PlanetCategory) < 2;
    }
    
    public async Task<bool> HasAccessAsync(Channel channel, long userId)
    {
        if (channel.PlanetId is not null)
        {
            var member = await _memberService.GetCurrentAsync(channel.PlanetId.Value);
            if (member is null)
                return false;
            
            return await _planetPermissionService.HasChannelAccessAsync(member.Id, channel.Id);
        }
        
        return await _db.ChannelMembers.AnyAsync(x => x.ChannelId == channel.Id && x.UserId == userId);
    }
    
    /// <summary>
    /// Returns the channel members for a given channel id,
    /// which is NOT planet members
    /// </summary>
    public Task<List<User>> GetDirectChannelMembersAsync(long channelId)
    {
        return _db.ChannelMembers.Include(x => x.User)
            .Where(x => x.ChannelId == channelId)
            .Select(x => x.User.ToModel())
            .ToListAsync();
    }
    
    #region Permissions
    
    /// <summary>
    /// Returns if a given member has a channel permission
    /// </summary>
    public async Task<bool> HasPermissionAsync(Channel channel, PlanetMember member, CategoryPermission permission) =>
        await _memberService.HasPermissionAsync(member, channel, permission);
    
    /// <summary>
    /// Returns if a given member has a channel permission
    /// </summary>
    public async Task<bool> HasPermissionAsync(Channel channel, PlanetMember member, ChatChannelPermission permission) =>
        await _memberService.HasPermissionAsync(member, channel, permission);
    
    /// <summary>
    /// Returns if a given member has a channel permission
    /// </summary>
    public async Task<bool> HasPermissionAsync(Channel channel, PlanetMember member, VoiceChannelPermission permission) =>
        await _memberService.HasPermissionAsync(member, channel, permission);

    /// <summary>
    /// Returns the permissions for a given member in a channel
    /// </summary>
    public ValueTask<long> GetPermissionsAsync(Channel channel, PlanetMember member, ChannelTypeEnum permType) =>
        _planetPermissionService.GetChannelPermissionsAsync(member, channel, permType);

    /// <summary>
    /// Returns the permissions nodes for the given channel id
    /// </summary>
    public async Task<List<PermissionsNode>> GetPermissionNodesAsync(long channelId) =>
        await _db.PermissionsNodes.Where(x => x.TargetId == channelId)
            .Select(x => x.ToModel())
            .ToListAsync();
    
    #endregion
    
    /// <summary>
    /// Returns all the descendents for a given channel position
    /// </summary>
    public async Task<List<Channel>> GetAllDescendants(Channel channel)
    {
        if (channel.ChannelType != ChannelTypeEnum.PlanetCategory)
            return new();
        
        // This works because position values contain the parent information.
        
        // First, get the depth of the channel
        var depth = channel.Position.Depth;
        
        // If depth is 4, it can't have children
        // (Technically you shouldn't even be able to have a category at level 4)
        if (depth == 4)
            return new();
        
        var descendants = await _db.Channels
            .DescendantsOf(channel)
            .Select(x => x.ToModel())
            .ToListAsync();
        
        return descendants;
    }
    
    ////////////////
    // Validation //
    ////////////////
    
    /// <summary>
    /// Validates that a given name is allowable
    /// </summary>
    private static TaskResult ValidateName(string name)
    {
        if (name.Length > 32)
            return TaskResult.FromFailure("Channel names must be 32 characters or less.");

        return TaskResult.SuccessResult;
    }
    
    /// <summary>
    /// Validates that a given description is allowable
    /// </summary>
    private static TaskResult ValidateDescription(string desc)
    {
        if (desc.Length > 500)
        {
            return TaskResult.FromFailure("Planet descriptions must be 500 characters or less.");
        }

        return TaskResult.SuccessResult;
    }

    private static TaskResult ValidateAssociatedChatLink(Channel channel)
    {
        if (channel.AssociatedChatChannelId is null)
            return TaskResult.SuccessResult;

        if (!IsPlanetCallChannelType(channel.ChannelType))
            return TaskResult.FromFailure("Only planet voice/video channels can have an associated chat channel.");

        if (channel.PlanetId is null)
            return TaskResult.FromFailure("Associated chat channels can only be set on planet call channels.");

        return TaskResult.SuccessResult;
    }
    
    
    /// <summary>
    /// Ensures the position is unique
    /// </summary>
    private async Task<bool> HasUniquePosition(Channel channel) =>
        // Ensure position is not already taken
        // Note: with new position system, we need to check the position and parent separately
        !await _db.Channels.AnyAsync(x => (x.ParentId == channel.ParentId && // Same parent
                                                x.RawPosition == channel.RawPosition) && // Same position
                                                x.Id != channel.Id); // Not self
    
    /// <summary>
    /// Ensures the parent and position are valid
    /// </summary>
    private async Task<TaskResult> ValidateParentAndPosition(Channel channel)
    {
        // Logic to check if parent is legitimate
        if (channel.ParentId is not null)
        {
            // Only planet channels can have a parent
            if (channel.PlanetId is null)
            {
                return TaskResult.FromFailure("Only planet channels can have a parent.");
            }
            
            var parent = await _db.Channels.FirstOrDefaultAsync
            (x => x.Id == channel.ParentId
                  && x.PlanetId == channel.PlanetId // This ensures the result has the same planet id
                  && x.ChannelType == ChannelTypeEnum.PlanetCategory); // Only categories can be parents 

            if (parent is null)
                return TaskResult.FromFailure( "Parent channel not found");
            
            if (parent.Id == channel.Id)
                return TaskResult.FromFailure( "A channel cannot be its own parent.");

            // Ensure that the channel is not a descendant of itself
            var loopScan = parent;
            
            while (loopScan!.ParentId is not null)
            {
                if (loopScan.ParentId == channel.Id)
                    return TaskResult.FromFailure("A channel cannot be a descendant of itself.");

                loopScan = await _db.Channels.FirstOrDefaultAsync(x => x.Id == loopScan.ParentId);
            }
            
        }

        // Auto determine position
        if (channel.RawPosition == 0)
        {
            var nextPosResult = await TryGetNextChannelPositionFor(channel);
            if (!nextPosResult.Success)
                return nextPosResult.WithoutData();
            
            channel.RawPosition = nextPosResult.Data;
        }
        else
        {
            if (!await HasUniquePosition(channel))
                return TaskResult.FromFailure( "The position is already taken.");
        }

        return TaskResult.SuccessResult;
    }

    /// <summary>
    /// Validates the planet of a channel
    /// </summary>
    private async Task<TaskResult> ValidatePlanet(Channel channel)
    {
        if (ISharedChannel.PlanetChannelTypes.Contains(channel.ChannelType))
        {
            if (!await _db.Planets.AnyAsync(x => x.Id == channel.PlanetId))
            {
                return TaskResult.FromFailure("Planet not found.");
            }
        }
        else
        {
            if (channel.PlanetId is not null)
            {
                return TaskResult.FromFailure("Only planet channel types can have a planet id.");
            } 
        }

        return TaskResult.SuccessResult;
    }
    
    /// <summary>
    /// Common basic validation for channels
    /// </summary>
    private async Task<TaskResult> ValidateChannel(Channel channel)
    {
        var planetValid = await ValidatePlanet(channel);
        if (!planetValid.Success)
            return planetValid;
        
        var nameValid = ValidateName(channel.Name);
        if (!nameValid.Success)
            return nameValid;

        var descValid = ValidateDescription(channel.Description);
        if (!descValid.Success)
            return descValid;
        
        var associatedChatValid = ValidateAssociatedChatLink(channel);
        if (!associatedChatValid.Success)
            return associatedChatValid;

        var positionValid = await ValidateParentAndPosition(channel);
        if (!positionValid.Success)
            return positionValid;

        return TaskResult.SuccessResult;
    }

    public async Task<TaskResult<uint>> TryGetNextChannelPositionFor(ISharedChannel inserting)
    {
        if (inserting.PlanetId is null)
        {
            return TaskResult<uint>.FromFailure("Non-planet channels cannot be inserted.");
        }
        
        return await TryGetNextChannelPositionFor(inserting.PlanetId.Value, inserting.ParentId, inserting.ChannelType);
    }

    public async Task<TaskResult<uint>> TryGetNextChannelPositionFor(long planetId, long? parentId, ChannelTypeEnum insertingType)
    {
        var parent = parentId is null ? null : await _db.Channels.FindAsync(parentId);
        
        if (parent is not null)
        {
            // Ensure the parent is a category
            if (parent.ChannelType != ChannelTypeEnum.PlanetCategory)
            {
                return TaskResult<uint>.FromFailure("Parent must be a category or null.");
            }
            
            // If the channel being inserted is a category, ensure that it's not too deeply nested
            if (insertingType == ChannelTypeEnum.PlanetCategory)
            {
                if (ChannelPosition.GetDepth(parent.RawPosition) > 2)
                {
                    return TaskResult<uint>.FromFailure("Categories cannot be nested more than 3 levels deep.");
                }
            }
        }
        
        // Get the highest local position in the category

        uint max = 0;

        if (parent is not null)
        {
            if (await _db.Channels.DirectChildrenOf(parent).AnyAsync())
            {
                max = await _db.Channels.DirectChildrenOf(parent).MaxAsync(x => x.RawPosition);
            }
        }
        else
        {
            var rootChannels = _db.Channels
                .Where(x => x.PlanetId == planetId && x.ParentId == null);

            if (await rootChannels.AnyAsync())
            {
                max = await rootChannels.MaxAsync(x => x.RawPosition);
            }
        }

        var localMax = ChannelPosition.GetLocalPosition(max);
        
        if (localMax == byte.MaxValue)
        {
            return TaskResult<uint>.FromFailure("Max position reached");
        }
        
        var parentPos = parent is null ? new ChannelPosition(0) : new ChannelPosition(parent.RawPosition);
        var nextPos = ChannelPosition.AppendRelativePosition(parentPos.RawPosition, localMax + 1);
        
        // Give the next position
        return TaskResult<uint>.FromData(nextPos);
    }
    
    public async Task<List<Channel>> GetDescendants(Channel channel)
    {
        if (channel.ChannelType != ChannelTypeEnum.PlanetCategory)
            return [];
        
        var descendants = new List<Channel>();
        await AddDescendants(channel, descendants);

        return descendants;
    }

    public async Task AddDescendants(Channel channel, List<Channel> list)
    {
        var children = await _db.Channels.DirectChildrenOf(channel)
            .Select(x => x.ToModel())
            .ToListAsync();
        
        list.AddRange(children);
        
        foreach (var child in children)
        {
            await AddDescendants(child, list);
        }
    }

    private void AddChannelsToLookup(
        ICollection<Valour.Database.Channel>? rootChannels, 
        Dictionary<long, Valour.Database.Channel> channelLookup)
    {
        if (rootChannels is null || rootChannels.Count == 0)
            return;
        
        foreach(var channel in rootChannels)
        {
            channelLookup[channel.Id] = channel;
            AddChannelsToLookup(channel.Children, channelLookup);
        }
    }

    /// <summary>
    /// Used AFTER the parent's position is changed to update the children
    /// </summary>
    private void UpdateChildrenForPositionChange(
        Valour.Database.Channel channel,
        Dictionary<long, Channel> updatedChannels,
        ChannelsMovedEvent eventData)
    {
        uint nextPos = 1;
        if (channel.Children is not null)
        {
            foreach (var child in channel.Children)
            {
                // Update child position
                child.RawPosition = ChannelPosition.AppendRelativePosition(channel.RawPosition, nextPos);
                _db.Channels.Update(child);

                eventData.Moves[child.Id] = new ChannelMove()
                {
                    ChannelId = child.Id,
                    NewRawPosition = child.RawPosition,
                    NewParentId = child.ParentId
                };

                updatedChannels[child.Id] = child.ToModel();

                // Propagate to grandchildren
                UpdateChildrenForPositionChange(child, updatedChannels, eventData);

                nextPos++;
            }
        }
    }

    public async Task<TaskResult> MoveChannelAsync(
        long planetId,
        long toMoveId, // The channel to be moved
        long? destinationChannelId, // The channel in the position the channel will be moved to
        bool insertBefore, // If the channel should be inserted before the destination channel, or default after
        bool insideCategory = false) // If true and destination is a category, move inside it; if false, treat as sibling
    {
        // Get entire tree of channels
        // We do this to ensure we never break the tree structure
        // when we manipulate raw positions. Expensive, yes - but
        // moving channels is not a common operation.
        var channelsTree = await _db.Channels
            .Where(x => x.PlanetId == planetId && x.ParentId == null) // Layer 1 (root)
            .Include(x => x.Children.OrderBy(y => y.RawPosition)) // Layer 2
            .ThenInclude(x => x.Children.OrderBy(y => y.RawPosition)) // Layer 3
            .ThenInclude(x => x.Children.OrderBy(y => y.RawPosition)) // Layer 4
            .OrderBy(x => x.RawPosition)
            .ToListAsync();

        // Build a lookup for the channels
        var channelLookup = new Dictionary<long, Valour.Database.Channel>();
        AddChannelsToLookup(channelsTree, channelLookup);
        
        if (!channelLookup.TryGetValue(toMoveId, out var toMove))
            return TaskResult.FromFailure("ToMove Channel not found.");
        
        Valour.Database.Channel? destinationCategory = null;
        Valour.Database.Channel? destinationChannel = null;

        if (destinationChannelId != null) {

            if (!channelLookup.TryGetValue(destinationChannelId.Value, out destinationChannel))
            {
                return TaskResult.FromFailure("Destination channel not found.");
            }

            if (destinationChannel.ChannelType == ChannelTypeEnum.PlanetCategory)
            {
                if (insideCategory)
                {
                    // Move inside the category (append as child)
                    destinationCategory = destinationChannel;
                    destinationChannel = null;
                }
                else
                {
                    // Treat the category as a sibling - find its parent
                    if (destinationChannel.ParentId is not null)
                    {
                        if (!channelLookup.TryGetValue(destinationChannel.ParentId.Value, out destinationCategory))
                        {
                            return TaskResult.FromFailure("Destination category's parent not found.");
                        }
                    }
                    // else: destinationCategory stays null (root level), destinationChannel stays as the category
                }
            }
            else
            {
                if (destinationChannel.ParentId is not null)
                {
                    if (!channelLookup.TryGetValue(destinationChannel.ParentId.Value, out destinationCategory))
                    {
                        return TaskResult.FromFailure("Destination category not found.");
                    }
                }
            }
        }

        if (destinationCategory is not null)
        {
            if (destinationCategory.Id == toMove.Id)
                return TaskResult.FromFailure("Cannot move a channel into itself.");

            if (destinationCategory.ChannelType != ChannelTypeEnum.PlanetCategory)
                return TaskResult.FromFailure("Destination category is not a category.");
            
            // Protect from dangerous channel loops. Although, the way channel lists are built now, this
            // isn't quite as bad as it used to be, since it's not recursive.
            var toMovePos = new ChannelPosition(toMove.RawPosition);
            var destinationPos = new ChannelPosition(destinationCategory.RawPosition);
            if (ChannelPosition.ContainsPosition(toMovePos, destinationPos))
            {
                return TaskResult.FromFailure("Move resulted in a loop");
            }
        }

        await using var trans = await _db.Database.BeginTransactionAsync();

        try
        {
            Dictionary<long, Channel> updatedChannels = new();
            ChannelsMovedEvent eventData = new(toMove.PlanetId!.Value);

            // If we're moving to a new category, we need to handle siblings in the old category
            if (toMove.ParentId != destinationCategory?.Id)
            {
                var oldCategory = toMove.ParentId is null ? null : await _db.Channels.FindAsync(toMove.ParentId);
                
                // Get old siblings
                var oldSiblings = oldCategory?.Children;

                if (oldSiblings is not null && oldSiblings.Count > 0)
                {
                    // They should be ordered properly, so we rebuild the local positions
                    // by just appending an iterated int to the new parent position
                    var oldParentPos = oldCategory is null ? 
                        new ChannelPosition(0) : new ChannelPosition(oldCategory.RawPosition);
                    
                    uint nextPos = 1;
                    
                    foreach (var sibling in oldSiblings)
                    {
                        var newPos = ChannelPosition.AppendRelativePosition(oldParentPos.RawPosition, nextPos);
                        
                        if (sibling.RawPosition != newPos)
                        {
                            sibling.RawPosition = newPos;
                            _db.Channels.Update(sibling);
                            
                            eventData.Moves[sibling.Id] = new ChannelMove()
                            {
                                ChannelId = sibling.Id,
                                NewRawPosition = sibling.RawPosition,
                                NewParentId = sibling.ParentId
                            };
                            
                            updatedChannels[sibling.Id] = sibling.ToModel();
                            
                            // Update descendants
                            UpdateChildrenForPositionChange(sibling, updatedChannels, eventData);
                        }
                        
                        nextPos++;
                    }
                    
                    await _db.SaveChangesAsync();
                }
            }
            
            if (destinationChannel is null) // Just append
            {
                // Simpler case: no need to move any new siblings around. Just get the next position and stick it there.
                
                // Update the target channel's parent
                toMove.ParentId = destinationCategory?.Id;
                
                // Get the next position
                var nextPosResult = await TryGetNextChannelPositionFor(toMove);
                if (!nextPosResult.Success)
                    return nextPosResult.WithoutData();
                
                toMove.RawPosition = nextPosResult.Data;
                
                updatedChannels[toMove.Id] = toMove.ToModel();
                
                eventData.Moves[toMove.Id] = new ChannelMove()
                {
                    ChannelId = toMove.Id,
                    NewRawPosition = toMove.RawPosition,
                    NewParentId = toMove.ParentId
                };
                
                _db.Channels.Update(toMove);
                
                // Update descendants
                UpdateChildrenForPositionChange(toMove, updatedChannels, eventData);
            }
            else
            {
                // More complicated, but we're doing it the easy way.
                // Get the new siblings, slip in the channel, and recalculate the positions.

                if (destinationChannel.Id == toMove.Id)
                {
                    // No work to do
                    return TaskResult.SuccessResult;
                }
                
                // Get the siblings the channel will have in the new category
                var newSiblings = destinationCategory?.Children.ToList() ?? channelsTree;

                // Remove the channel being moved if it already exists.
                newSiblings.RemoveAll(x => x.Id == toMove.Id);
                
                if (insertBefore)
                {
                    // Insert before the destination channel
                    var destinationIndex = newSiblings.FindIndex(x => x.Id == destinationChannel.Id);
                    if (destinationIndex == -1)
                    {
                        return TaskResult.FromFailure("Destination (before) channel index not found.");
                    }

                    newSiblings.Insert(destinationIndex, toMove);
                }
                else
                {
                    // Insert after the destination channel
                    var destinationIndex = newSiblings.FindIndex(x => x.Id == destinationChannel.Id);
                    if (destinationIndex == -1)
                    {
                        return TaskResult.FromFailure("Destination (after) channel index not found.");
                    }

                    newSiblings.Insert(destinationIndex + 1, toMove);
                }
                
                toMove.ParentId = destinationCategory?.Id;
                
                // Rebuild the local positions
                var parentPos = destinationCategory is null ? 
                    new ChannelPosition(0) : new ChannelPosition(destinationCategory.RawPosition);
                
                uint nextPos = 1;
                
                foreach (var sibling in newSiblings)
                {
                    var newPos = ChannelPosition.AppendRelativePosition(parentPos.RawPosition, nextPos);
                    
                    if (sibling.RawPosition != newPos)
                    {
                        sibling.RawPosition = newPos;
                        _db.Channels.Update(sibling);
                        
                        eventData.Moves[sibling.Id] = new ChannelMove()
                        {
                            ChannelId = sibling.Id,
                            NewRawPosition = sibling.RawPosition,
                            NewParentId = sibling.ParentId
                        };
                        
                        updatedChannels[sibling.Id] = sibling.ToModel();
                        
                        _db.Channels.Update(sibling);
                        
                        // Update descendants
                        UpdateChildrenForPositionChange(sibling, updatedChannels, eventData);
                    }
                    
                    nextPos++;
                }
            }
            
            await _db.SaveChangesAsync();
            
            var hostedPlanet = await _hostedPlanetService.GetRequiredAsync(toMove.PlanetId.Value);
            
            // Update channels in hosted planet
            foreach (var change in updatedChannels)
            {
                hostedPlanet.UpsertChannel(change.Value);
            }
            
            await _db.SaveChangesAsync();
            
            await trans.CommitAsync();

            await _planetPermissionService.HandleChannelTopologyChange(planetId);
            
            _coreHub.NotifyChannelsMoved(eventData);
        }
        catch (Exception e)
        {
            await trans.RollbackAsync();
            return TaskResult.FromFailure("An unexpected error occured.");
        }

        return TaskResult.SuccessResult;
    }

    public async Task<int> BackfillAssociatedCallChatsAsync()
    {
        var callChannelsMissingChat = await _db.Channels
            .Where(x => !x.IsDeleted &&
                        x.PlanetId != null &&
                        (x.ChannelType == ChannelTypeEnum.PlanetVoice || x.ChannelType == ChannelTypeEnum.PlanetVideo))
            .Where(x => _db.Planets.Any(p => p.Id == x.PlanetId))
            .Where(x => x.AssociatedChatChannelId == null ||
                        !_db.Channels.Any(y => y.Id == x.AssociatedChatChannelId && !y.IsDeleted))
            .OrderBy(x => x.PlanetId)
            .ThenBy(x => x.RawPosition)
            .ToListAsync();

        if (callChannelsMissingChat.Count == 0)
            return 0;

        var migratedCount = 0;
        var changedPlanetIds = new HashSet<long>();

        foreach (var dbCallChannel in callChannelsMissingChat)
        {
            var result = await CreateAssociatedChatFromExistingCallAsync(dbCallChannel);
            if (!result.Success)
            {
                _logger.LogWarning(
                    "Failed to create associated chat for call channel {ChannelId}: {Message}",
                    dbCallChannel.Id,
                    result.Message);
                continue;
            }

            migratedCount++;
            changedPlanetIds.Add(dbCallChannel.PlanetId!.Value);
        }

        foreach (var planetId in changedPlanetIds)
        {
            await _planetPermissionService.HandleChannelTopologyChange(planetId);
        }

        return migratedCount;
    }

    private async Task<TaskResult> CreateAssociatedChatFromExistingCallAsync(Valour.Database.Channel dbCallChannel)
    {
        if (dbCallChannel.PlanetId is null)
            return TaskResult.FromFailure("Call channel is not a planet channel.");

        await using var tran = await _db.Database.BeginTransactionAsync();

        try
        {
            var associatedChatChannel = new Channel
            {
                Id = IdManager.Generate(),
                Name = dbCallChannel.Name,
                Description = $"Integrated chat for {dbCallChannel.Name}",
                ChannelType = ChannelTypeEnum.PlanetChat,
                LastUpdateTime = dbCallChannel.LastUpdateTime,
                PlanetId = dbCallChannel.PlanetId,
                ParentId = dbCallChannel.ParentId,
                RawPosition = 0,
                InheritsPerms = dbCallChannel.InheritsPerms,
                IsDefault = false,
                Nsfw = dbCallChannel.Nsfw
            };

            var chatValidation = await ValidateChannel(associatedChatChannel);
            if (!chatValidation.Success && associatedChatChannel.ParentId is not null)
            {
                // Legacy data can contain invalid parent relationships.
                // Fall back to root-level placement.
                associatedChatChannel.ParentId = null;
                associatedChatChannel.RawPosition = 0;
                chatValidation = await ValidateChannel(associatedChatChannel);
            }

            if (!chatValidation.Success)
            {
                await tran.RollbackAsync();
                return TaskResult.FromFailure(chatValidation.Message);
            }

            dbCallChannel.AssociatedChatChannelId = associatedChatChannel.Id;
            _db.Channels.Update(dbCallChannel);
            await _db.Channels.AddAsync(associatedChatChannel.ToDatabase());
            await _db.SaveChangesAsync();

            var sourceNodes = await _db.PermissionsNodes
                .AsNoTracking()
                .Where(x => x.TargetId == dbCallChannel.Id &&
                            (x.TargetType == ChannelTypeEnum.PlanetVoice || x.TargetType == ChannelTypeEnum.PlanetVideo))
                .Select(x => x.ToModel())
                .ToListAsync();

            var mappedNodes = BuildAssociatedChatPermissionNodes(
                sourceNodes,
                dbCallChannel.PlanetId.Value,
                dbCallChannel.Id,
                associatedChatChannel.Id);

            if (mappedNodes.Count > 0)
            {
                await _db.PermissionsNodes.AddRangeAsync(mappedNodes.Select(x => x.ToDatabase()));
                await _db.SaveChangesAsync();
            }

            await tran.CommitAsync();

            if (_hostedPlanetService.IsHosted(dbCallChannel.PlanetId.Value))
            {
                var hostedPlanet = await _hostedPlanetService.GetRequiredAsync(dbCallChannel.PlanetId.Value);
                hostedPlanet.UpsertChannel(dbCallChannel.ToModel());
                hostedPlanet.UpsertChannel(associatedChatChannel);

                _coreHub.NotifyPlanetItemChange(dbCallChannel.PlanetId.Value, dbCallChannel.ToModel());
                _coreHub.NotifyPlanetItemChange(dbCallChannel.PlanetId.Value, associatedChatChannel);
            }

            return TaskResult.SuccessResult;
        }
        catch (Exception e)
        {
            await tran.RollbackAsync();
            _logger.LogError(e, "Failed creating associated chat for call channel {ChannelId}", dbCallChannel.Id);
            return TaskResult.FromFailure("Failed to create associated chat channel.");
        }
    }
    
    private static int _migratedChannels = 0;

    public async Task MigrateChannels()
    {
        // From V0 -> V3, we convert the position to the new format

        /*
        var channels = await _db.Channels.Where(x => x.PlanetId == ISharedPlanet.ValourCentralId).ToListAsync();
        var basePos = new ChannelPosition(0);
        for (var i = 0; i < channels.Count; i++)
        {
            var channel = channels[i];
            channel.RawPosition = ChannelPosition.AppendRelativePosition(basePos.RawPosition, (uint)(i + 1));
            channel.ParentId = null;
            _db.Channels.Update(channel);
            await _db.SaveChangesAsync();
        }
        */
        
        // Non-planet channels just get updated to version 2
        await _db.Channels.Where(x => x.PlanetId == null)
            .ExecuteUpdateAsync(u => u.SetProperty(c => c.Version, 8));
        
        var rootChannels = await _db.Channels
            .Where(x => x.Version < 8
                && x.PlanetId != null
                && x.ParentId == null)
            .ToListAsync();
        
        // Build set of planets
        var planets = new HashSet<long>();
        foreach (var root in rootChannels)
        {
            planets.Add(root.PlanetId!.Value);
        }

        foreach (var planetId in planets)
        {
            var rootChannelsForPlanet = rootChannels.Where(x => x.PlanetId == planetId).ToList();
            
            // Sort the root channels by position
            rootChannelsForPlanet.Sort((a, b) => a.RawPosition.CompareTo(b.RawPosition));

            var ri = 1;
            foreach (var rootChannel in rootChannelsForPlanet)
            {
                var rootPos = ChannelPosition.AppendRelativePosition(0, (uint)ri, 1);
                ri++;
                
                await MigrateChannel(rootChannel, rootPos);
                
                await _db.SaveChangesAsync();
                
                _logger.LogInformation("Migrated channel tree, total {ChannelCount}", _migratedChannels);
            }
        }
    }

    public async Task MigrateChannel(Valour.Database.Channel channel, uint newPosition)
    {
        channel.RawPosition = newPosition;
        channel.Version = 8;
        
        _db.Channels.Update(channel);
        
        _migratedChannels++;
        
        // Migrate children
        var children = await _db.Channels
            .Where(x => x.ParentId == channel.Id)
            .OrderBy(x => x.RawPosition)
            .ToListAsync();
        
        var ci = 1;
        foreach (var child in children)
        {
            var childPos = ChannelPosition.AppendRelativePosition(newPosition, (uint)ci);
            ci++;
            await MigrateChannel(child, childPos);
        }
    }
    
    public async Task GetPlanetChannelMembers(long planetId, long channelId)
    {
        var hostedPlanet = await _hostedPlanetService.GetRequiredAsync(planetId);
    }
}
