@implements IAsyncDisposable
@inject INativeWindowService NativeWindowService

<div id="tab-@WindowTab.Id"
     class="window-wrapper @WindowWrapperClasses"
     style="@WindowWrapperStyles z-index: @ZIndex"
     @ref="@OuterWindowRef"
     @onmouseup:stopPropagation="true"
     @onmouseup="@OnWindowMouseUp">
    <div class="tab-wrapper @TabWrapperClasses"
         @onclick:stopPropagation="true"
         @onclick="@OnClickTab"
         @onmousedown:stopPropagation="true"
         @onmousedown:preventDefault="true"
         @onmousedown="@OnTabDown"
         @onmousemove:stopPropagation="true"
         @onmousemove:preventDefault="true"
         style="@TabWrapperStyle">
        @* Mobile does not have tabs *@
        @if (!DeviceInfo.IsMobile)
        {
            <div 
                class="tab">
                <div class="tab-info">
                    <img alt="tab icon" class="tab-icon" src="@Icon"/>
                    <span class="tab-title">@Title</span>
                </div>
                <div class="tab-buttons"
                     @onclick:stopPropagation="true"
                     @onmousedown:stopPropagation="true">
                    @if (CanPopOutToNativeWindow)
                    {
                        <span class="popout" title="Pop out into a new window" @onclick="@OnClickPopout">
                            <i class="bi bi-box-arrow-up-right"></i>
                        </span>
                    }
                    <span class="minus" @onclick="@OnClickMinus">
                        <i class="bi bi-dash-circle-fill"></i>
                    </span>
                </div>
                
                @if (ShouldShowTabTarget) // Tab-specific drop targets
                {
                    <div
                        @onclick:stopPropagation="true"
                        @onclick="OnDropOnTab"
                        @ondrop:stopPropagation="true"
                        @ondrop="OnDropOnTab"
                        class="w-drop-target">
                    </div>
                }
            </div>
            
            @if (IsLastTab)
            {
                <div 
                    class="tab add" 
                    @onclick="@OnClickPlus"
                    @onclick:stopPropagation="true"
                    @onmousedown:stopPropagation="true"
                    @onmousedown:preventDefault="true"
                >
                    <i class="bi bi-plus-square"></i>
                </div>
            }
        }
    </div>
    <div class="window"
         style="@WindowStyle"
         @onclick:stopPropagation="true"
         @onclick="@OnClickWindow">
        @* Window Content *@
        @(WindowTab.Content?.RenderContent ?? HomeWindowComponent.DefaultContent.RenderContent)
        
        @if (ShouldShowDropTargets) // floating tabs don't have drop targets
        { 
            <WindowDropTargets Window="@this"/>
        }
    </div>
</div>

@code {

    public bool ShouldShowDropTargets =>
        !IsFloating && // Only show drop targets for docked windows
        (Layout?.FocusedTab == this.WindowTab) && // Needs to be the visible tab on the layout
        ((WindowService.DraggingTab is not null &&
          WindowService.DraggingTab != WindowTab) ||
         ChannelDragManager.Dragging);
    
    public bool ShouldShowTabTarget =>
        !IsFloating && // Only show drop targets for docked windows
        // (Layout?.FocusedTab == this.WindowTab) && // DOES NOT Need to be the visible tab on the layout
        ((WindowService.DraggingTab is not null &&
          WindowService.DraggingTab != WindowTab) ||
         ChannelDragManager.Dragging);
    
    public ElementReference OuterWindowRef { get; private set; }

    ////////////
    // Params //
    ////////////
    [Parameter] public WindowTab WindowTab { get; set; }
    [Parameter] public WindowDockComponent Dock { get; set; }
    
    ///////////////////////
    // Public properties //
    ///////////////////////
    public WindowLayout Layout => WindowTab.Layout;
    public bool IsActive => Layout?.FocusedTab == WindowTab;
    public bool IsFloating => WindowTab.IsFloating;
    private bool IsLastTab => Layout is not null && (Layout.Tabs.Last().Id == WindowTab.Id);
    private bool CanPopOutToNativeWindow => NativeWindowService.SupportsTabPopout && !DeviceInfo.IsMobile;

    ///////////////////////
    // Private properties //
    ///////////////////////
    
    private int ZIndex => IsFloating ? (IsActive ? 101 : 100) : (IsActive ? 2 : 1);

    private string TabWrapperStyle => IsFloating ? string.Empty : $"width: {GetTabWidth()}%; margin-left: min({250 * GetIndex()}px, {GetTabWidth() * GetIndex()}%)";

    private string TabWrapperClasses
    {
        get
        {
            string classes;
            if (IsFloating)
            {
                classes = "floating ";
            }
            else
            {
                classes = "docked ";
                
                if (GetIndex() == Layout.Tabs.Count - 1)
                {
                    classes += "last ";
                }
            }

            return classes;
        }
    }

    private string WindowWrapperClasses
    {
        get
        {
            var classes = IsFloating ? "floating " : "docked ";
            
            if (IsActive)
                classes += "active ";
            
            if (_dragging)
                classes += "dragging ";

            return classes;
        }
    }

    private string WindowWrapperStyles
    {
        // Floating window uses floating props, otherwise uses layout
        get
        {
            if (IsFloating && WindowTab.FloatingProps is not null)
            {
                return $"top: {WindowTab.FloatingProps.Y}px; left: {WindowTab.FloatingProps.X}px; width: {WindowTab.FloatingProps.Width}px; height: {WindowTab.FloatingProps.Height}px;";
            }
            
            return Layout?.Position.Style ?? string.Empty;
        }
    }

    private string Icon => WindowTab.Content?.Icon ?? HomeWindowComponent.DefaultContent.Icon;
    private string Title => WindowTab.Content?.Title ?? HomeWindowComponent.DefaultContent.Title;
    private Type Type => WindowTab.Content.ComponentType ?? HomeWindowComponent.DefaultContent.ComponentType;

    private string WindowStyle
    {
        get
        {
            var styles = string.Empty;
            if (WindowTab.Content?.AutoScroll ?? true)
            {
                styles += "overflow-y: auto;";
            }
            
            return styles;
        }
        
    } 
    
    ///////////////
    // Lifecycle //
    ///////////////
    
    // Render flag: blocks or allows rendering
    private bool _canRender = false;
    protected override bool ShouldRender() => _canRender;

    protected override void OnInitialized()
    {
        Console.WriteLine("Initialized window tab component " + WindowTab.Id);
        
        WindowTab.Component = this;
        BrowserUtils.OnWindowResize += OnWindowResize;
        WindowService.OnTabDragging += OnGlobalTabDragging;
        ChannelDragManager.ChannelDragChanged += OnChannelDragChanged;
    }

    // Runs after every render
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Reset render flag
        _canRender = false;

        if (_armFloatEvent)
        {
            _armFloatEvent = false;
            await WindowTab.NotifyFloating(); // Fire off event
        }

        if (_armJsDrag)
        {
            _armJsDrag = false;
            // Element is now in the DOM after render — start JS-side drag
            await MouseListener.StartDrag(
                $"tab-{WindowTab.Id}",
                WindowTargetScanner.JsService
            );
        }
    }
    
    public void ReRender()
    {
        _canRender = true;
        InvokeAsync(StateHasChanged);
    }
    
    
    public async Task ReplaceAsync(WindowContent content)
    {
        await WindowTab.SetContent(content);
        ReRender();
    }

    public async Task CloseAsync()
    {
        if (!IsFloating)
        {
            await Layout.RemoveTab(WindowTab);
        }
        else
        {
            await Dock.RemoveFloatingTab(WindowTab);
        }
    }

    public async Task AddSiblingTab(WindowContent content)
    {
        if (DeviceInfo.IsMobile)
        {
            await ReplaceAsync(content);
        }
        
       await Layout.AddTab(content);
    }

    public void NotifyNeedsReRender()
    {
        ReRender();
    }
    
    private float GetTabWidth()
    {
        if (Layout.Tabs.Count == 1)
            return 100f;
        
        return (100f / Layout.Tabs.Count);
    }

    private int GetIndex()
    {
        if (Layout is null)
            return 0;
        
        return Layout.Tabs.IndexOf(WindowTab);
    }

    private async Task SetFocused()
    {
        if (Layout is not null)
            await Layout.SetFocusedTab(WindowTab);
    }
    
    // For the layout to tell this tab the tab-stack has changed
    public void NotifyLayoutChanged()
    {
        ReRender();
    }

    private async Task OnClickPlus()
    {
        await AddSiblingTab(HomeWindowComponent.DefaultContent);
    }
    
    private async Task OnClickMinus()
    {
        await CloseAsync();
    }

    private async Task OnClickPopout()
    {
        if (!CanPopOutToNativeWindow || WindowTab?.Content is null)
            return;

        var adapter = new WindowSaveLoadAdapter(Dock.Client);
        var exported = adapter.Export(new List<WindowTab> { WindowTab }).FirstOrDefault();
        if (exported is null)
            return;

        var popoutKey = NativeTabPopoutStore.Add(exported);
        var opened = await NativeWindowService.TryOpenTabPopoutWindow(popoutKey, Title);
        if (!opened)
        {
            NativeTabPopoutStore.TryTake(popoutKey, out _);
            return;
        }

        await CloseAsync();
    }

    private Task OnClickTab(MouseEventArgs e)
    {
        return SetFocused();
    }
    
    private Task OnClickWindow()
    {
        // If the layout's focus has already moved to a different tab
        // (e.g. a click handler inside this window focused another window),
        // don't override that change.
        if (Layout?.FocusedTab != null && Layout.FocusedTab != WindowTab)
            return Task.CompletedTask;

        return SetFocused();
    }
    
    private Task OnClickHome()
    {
        return ReplaceAsync(HomeWindowComponent.DefaultContent);
    }

    
    ///////////////////////
    // Tab drag handling //
    ///////////////////////
    
    private float _dragStartX;
    private float _dragStartY;

    private bool _dragging = false;
    private bool _armFloatEvent = false; // Used to trigger event when the window starts floating. See OnAfterRenderAsync.
    private bool _armJsDrag = false; // Used to start JS drag after render (for dock->float transition). See OnAfterRenderAsync.
    private bool _subscribedToMove = false; // Tracks whether we're subscribed to mousemove

    /// <summary>
    /// Runs when the mouse goes down on the tab - prepares for dragging.
    /// </summary>
    private async Task OnTabDown(MouseEventArgs e)
    {
        // Store the start position
        _dragStartX = (float)e.ClientX;
        _dragStartY = (float)e.ClientY;

        // Enable mouse up listener globally (always needed for both paths)
        // Why not just use the up event on the tab? Because the mouse can move off the tab,
        // and we still want to be able to drag the tab. So we need to listen for the up event
        // globally.
        MouseListener.SubscribeMouseUp(OnTabUp);

        if (IsFloating)
        {
            // Already floating: start JS-side drag immediately (element exists in DOM)
            _dragging = true;
            WindowService.NotifyTabDragging(this.WindowTab);

            await MouseListener.StartDrag(
                $"tab-{WindowTab.Id}",
                WindowTargetScanner.JsService
            );

            ReRender();
        }
        else
        {
            // Docked: need mousemove to detect the 10px threshold before floating
            MouseListener.SubscribeMouseMove(OnDragTab);
            _subscribedToMove = true;
        }
    }

    private async Task OnTabUp(MouseUpEvent e)
    {
        // Stop JS drag if active, get final position
        var finalPos = await MouseListener.StopDrag();
        if (finalPos is not null && WindowTab.FloatingProps is not null)
        {
            WindowTab.FloatingProps.X = finalPos[0];
            WindowTab.FloatingProps.Y = finalPos[1];
        }

        _dragging = false;

        // End window target scanner
        await WindowTargetScanner.FinalizeAsync(e.X, e.Y);

        // Disable mouse move listener (only if we subscribed)
        if (_subscribedToMove)
        {
            MouseListener.UnsubscribeMouseMove(OnDragTab);
            _subscribedToMove = false;
        }

        // Disable mouse up listener
        MouseListener.UnsubscribeMouseUp(OnTabUp);

        WindowService.NotifyTabDragging(null);

        ReRender();
    }

    private async Task OnDragTab(MousePosition e)
    {
        if (!IsFloating)
        {
            if (_armFloatEvent)
            {
                return; // Waiting for render to float
            }

            // If not floating, we start floating if the mouse moves a certain distance
            if (Math.Abs(e.ClientX - _dragStartX) > 10 || Math.Abs(e.ClientY - _dragStartY) > 10)
            {
                Console.WriteLine("Started floating");

                _armFloatEvent = true;
                _armJsDrag = true;
                _dragging = true;

                // Unsubscribe from mousemove — JS will handle position updates
                MouseListener.UnsubscribeMouseMove(OnDragTab);
                _subscribedToMove = false;

                // Notify global windows of dragging (once)
                WindowService.NotifyTabDragging(this.WindowTab);

                await Layout.DockComponent.AddFloatingTab(WindowTab, new FloatingWindowProps()
                {
                    X = Math.Max(0, e.ClientX - 150),
                    Y = Math.Max(0, e.ClientY - 15),
                    Width = 300,
                    Height = 300,
                });
            }
        }
        else
        {
            // Fallback: if somehow we're still subscribed to mousemove while floating,
            // handle it the old way (should not normally be reached)
            WindowTab.FloatingProps.X += e.DeltaX;
            WindowTab.FloatingProps.Y += e.DeltaY;

            EnsureOnScreen();

            _dragging = true;

            // Notify global windows of dragging
            WindowService.NotifyTabDragging(this.WindowTab);

            // Run window target scanner
            await WindowTargetScanner.ScanAsync(e.ClientX, e.ClientY);
        }

        ReRender();
    }
    
    private Task OnDropOnTab()
    {
        if (WindowService.DraggingTab is not null)
        {
            return Layout.OnTabDropped(WindowService.DraggingTab, WindowTab);
        }
        else if (ChannelDragManager.CurrentDragItem is not null && ChannelDragManager.CurrentDragItem.Channel is not null)
        {
            return Layout.OnChannelDropped(ChannelDragManager.CurrentDragItem.Channel, WindowTab);
        }
        
        return Task.CompletedTask;
    }
    
    public async Task OnWindowMouseUp(MouseEventArgs e)
    {
        if (IsFloating)
        {
            // On floating windows we check if the element has been resized when the mouse is released
            var dims = await GetDimensions();
            WindowTab.FloatingProps.Width = dims.Width;
            WindowTab.FloatingProps.Height = dims.Height;
            
            Console.WriteLine("Updated floating window size to " + dims.Width + "x" + dims.Height);
            
            Dock.SaveFloaters();
        }
    }
    
    public async Task<ElementDimensions> GetDimensions()
    {
        return await BrowserUtils.GetElementDimensionsAsync(OuterWindowRef);
    }

    public bool EnsureOnScreen()
    {
        var changed = false;
        
        // Prevent going off screen
        if (WindowTab.FloatingProps.X < 0)
        {
            WindowTab.FloatingProps.X = 0;
            changed = true;
        }

        if (WindowTab.FloatingProps.Y < 0)
        {
            WindowTab.FloatingProps.Y = 0;
            changed = true;
        }

        if (WindowTab.FloatingProps.X + WindowTab.FloatingProps.Width > BrowserUtils.WindowDimensions.Width)
        {
            WindowTab.FloatingProps.X = BrowserUtils.WindowDimensions.Width - WindowTab.FloatingProps.Width;
            changed = true;
        }

        if (WindowTab.FloatingProps.Y + WindowTab.FloatingProps.Height > BrowserUtils.WindowDimensions.Height)
        {
            WindowTab.FloatingProps.Y = BrowserUtils.WindowDimensions.Height - WindowTab.FloatingProps.Height;
            changed = true;
        }

        return changed;
    }
    
    private Task OnWindowResize(ElementDimensions dims)
    {
        if (IsFloating)
        {
            var changed = EnsureOnScreen();
            if (changed)
            {
                ReRender();
            }
        }
        
        return Task.CompletedTask;
    }
    
    private void OnGlobalTabDragging(WindowTab tab)
    {
        if (tab == WindowTab)
            return;
        
        // If we aren't visible, we don't need to do anything
        //if (!IsActive)
        //    return;
        
        ReRender();
    }
    
    private void OnChannelDragChanged(Channel item)
    {
        ReRender();
    }
    
    ValueTask IAsyncDisposable.DisposeAsync()
    {
        BrowserUtils.OnWindowResize -= OnWindowResize;
        WindowService.OnTabDragging -= OnGlobalTabDragging;
        ChannelDragManager.ChannelDragChanged -= OnChannelDragChanged;
        
        return ValueTask.CompletedTask;
    }
}
