@inject IAppStorage LocalStorage
@inject ValourClient Client
@inject RealtimeKitDeviceService RealtimeKitDeviceService

<h3>Device Preferences</h3>
<p class="subtitle">DEVICE + ACCOUNT SETTINGS</p>

<div class="perm-section">
    <div class="perm-list-item">
        <div class="perm-list-name mb-1">
            Auto Emojis
        </div>
        <div type="button" style="float:right">
            <label class="switch">
                <input type="checkbox" @onclick="SwitchAutoEmojis" checked="@DevicePreferences.AutoEmoji">
                <span class="slider round"></span>
            </label>
        </div>
        <div class="perm-list-desc mt-1">
            When true, faces like :) will be automatically turned into emojis in chat.
        </div>
    </div>

    <div class="perm-list-item">
        <div class="perm-list-name mb-1">
            Error Reporting
        </div>
        <div type="button" style="float:right">
            <label class="switch">
                <input type="checkbox" @onclick="OnErrorReportingClick" checked="@_errorReportingEnabled">
                <span class="slider round"></span>
            </label>
        </div>
        <div class="perm-list-desc mt-1">
            <span>Share anonymous error reports to help improve Valour.</span>
        </div>
    </div>
</div>

<br />

<div class="perm-list-item">
    <div class="perm-list-name mb-1">
        Input Device (Microphone)
    </div>
    <div class="perm-list-desc mt-1">
        @GetMicPermissionDescription()
    </div>

    @if (_isLoadingMics)
    {
        <p class="help-text mt-2">Loading microphone devices...</p>
    }
    else if (_mics.Length == 0)
    {
        <p class="help-text mt-2">No microphones found yet.</p>
    }
    else
    {
        <select style="margin-top: 12px" class="form-select" value="@(_selectedMicId ?? string.Empty)" @onchange="@OnChooseMic">
            @for (int i = 0; i < _mics.Length; i++)
            {
                var mic = _mics[i];
                <option value="@mic.DeviceId">@mic.Label</option>
            }
        </select>
    }

    @if (ShouldShowMicPermissionButton)
    {
        <button class="v-btn mt-2 mr-2" disabled="@_isRequestingMicPermission" @onclick="OnRequestMicrophonePermissionAsync">
            @(_isRequestingMicPermission ? "Requesting Access..." : "Enable Microphone Access")
        </button>
    }

    <button class="v-btn mt-2" disabled="@_isLoadingMics" @onclick="OnRefreshMicsAsync">Refresh Devices</button>

    @if (!string.IsNullOrWhiteSpace(_micError))
    {
        <p class="help-text mt-2" style="color: var(--v-red);">@_micError</p>
    }
</div>

<div class="perm-list-item mt-3">
    <div class="perm-list-name mb-1">
        Input Device (Camera)
    </div>
    <div class="perm-list-desc mt-1">
        @GetCameraPermissionDescription()
    </div>

    @if (_isLoadingCameras)
    {
        <p class="help-text mt-2">Loading camera devices...</p>
    }
    else if (_cameras.Length == 0)
    {
        <p class="help-text mt-2">No cameras found yet.</p>
    }
    else
    {
        <select style="margin-top: 12px" class="form-select" value="@(_selectedCameraId ?? string.Empty)" @onchange="@OnChooseCamera">
            @for (int i = 0; i < _cameras.Length; i++)
            {
                var camera = _cameras[i];
                <option value="@camera.DeviceId">@camera.Label</option>
            }
        </select>
    }

    @if (ShouldShowCameraPermissionButton)
    {
        <button class="v-btn mt-2 mr-2" disabled="@_isRequestingCameraPermission" @onclick="OnRequestCameraPermissionAsync">
            @(_isRequestingCameraPermission ? "Requesting Access..." : "Enable Camera Access")
        </button>
    }

    <button class="v-btn mt-2" disabled="@_isLoadingCameras" @onclick="OnRefreshCamerasAsync">Refresh Devices</button>

    @if (!string.IsNullOrWhiteSpace(_cameraError))
    {
        <p class="help-text mt-2" style="color: var(--v-red);">@_cameraError</p>
    }
</div>


@code {

    private InputMic[] _mics = Array.Empty<InputMic>();
    private InputMic[] _cameras = Array.Empty<InputMic>();
    private string? _selectedMicId;
    private string? _selectedCameraId;
    private string _micPermissionState = "unknown";
    private string _cameraPermissionState = "unknown";
    private string? _micError;
    private string? _cameraError;
    private bool _isLoadingMics;
    private bool _isLoadingCameras;
    private bool _isRequestingMicPermission;
    private bool _isRequestingCameraPermission;
    private bool _hasInitializedDeviceLists;
    private bool _isInitializingDeviceLists;
    private int _initialDeviceLoadAttempts;
    private bool _errorReportingEnabled = DevicePreferences.ErrorReportingEnabled;
    private const int MaxInitialDeviceLoadAttempts = 20;
    private const string WebViewContextUnavailableMessage = "Cannot invoke JavaScript outside of a WebView context";

    private bool ShouldShowMicPermissionButton =>
        string.Equals(_micPermissionState, "prompt", StringComparison.OrdinalIgnoreCase) ||
        string.Equals(_micPermissionState, "unknown", StringComparison.OrdinalIgnoreCase);

    private bool ShouldShowCameraPermissionButton =>
        string.Equals(_cameraPermissionState, "prompt", StringComparison.OrdinalIgnoreCase) ||
        string.Equals(_cameraPermissionState, "unknown", StringComparison.OrdinalIgnoreCase);

    private async Task OnChooseMic(ChangeEventArgs e)
    {
        var selectedMicId = e.Value?.ToString() ?? string.Empty;
        _selectedMicId = selectedMicId;
        await DevicePreferences.SetMicrophoneDeviceId(selectedMicId, LocalStorage);
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadErrorReportingStateAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _ = firstRender;

        if (_hasInitializedDeviceLists || _isInitializingDeviceLists || _initialDeviceLoadAttempts >= MaxInitialDeviceLoadAttempts)
            return;

        _isInitializingDeviceLists = true;
        _initialDeviceLoadAttempts++;

        try
        {
            var micsLoaded = await RefreshMicsAsync();
            var camerasLoaded = await RefreshCamerasAsync();
            _hasInitializedDeviceLists = micsLoaded && camerasLoaded;

            if (!_hasInitializedDeviceLists && _initialDeviceLoadAttempts < MaxInitialDeviceLoadAttempts)
            {
                // WebView JS context can become available shortly after first render on some platforms.
                await Task.Delay(250);
                await InvokeAsync(StateHasChanged);
            }
        }
        finally
        {
            _isInitializingDeviceLists = false;
        }
    }

    private async Task OnRefreshMicsAsync()
    {
        await RefreshMicsAsync();
    }

    private async Task OnRequestMicrophonePermissionAsync()
    {
        _isRequestingMicPermission = true;
        await RefreshMicsAsync(requestPermission: true);
        _isRequestingMicPermission = false;
        StateHasChanged();
    }

    private async Task OnRefreshCamerasAsync()
    {
        await RefreshCamerasAsync();
    }

    private async Task OnRequestCameraPermissionAsync()
    {
        _isRequestingCameraPermission = true;
        await RefreshCamerasAsync(requestPermission: true);
        _isRequestingCameraPermission = false;
        StateHasChanged();
    }

    private async Task<bool> RefreshMicsAsync(bool requestPermission = false)
    {
        _isLoadingMics = true;
        _micError = null;
        StateHasChanged();

        try
        {
            if (requestPermission)
            {
                var granted = await RealtimeKitDeviceService.RequestMicrophonePermissionAsync();
                if (!granted)
                {
                    _micError = "Microphone permission was not granted.";
                }
            }

            _micPermissionState = await RealtimeKitDeviceService.GetMicrophonePermissionStateAsync();
            _mics = await RealtimeKitDeviceService.GetAudioInputDevicesAsync();

            if (_mics.Length == 0)
            {
                _selectedMicId = null;

                if (string.Equals(_micPermissionState, "denied", StringComparison.OrdinalIgnoreCase))
                {
                    _micError ??= "Microphone access is blocked. Enable it in browser site settings, then refresh devices.";
                }
            }
            else
            {
                var savedDeviceId = DevicePreferences.MicrophoneDeviceId;
                var hasSavedSelection = !string.IsNullOrWhiteSpace(savedDeviceId)
                    && _mics.Any(x => x.DeviceId == savedDeviceId);

                if (hasSavedSelection)
                {
                    _selectedMicId = savedDeviceId;
                }
                else
                {
                    _selectedMicId = _mics[0].DeviceId;

                    if (!string.IsNullOrWhiteSpace(_selectedMicId))
                    {
                        await DevicePreferences.SetMicrophoneDeviceId(_selectedMicId, LocalStorage);
                    }
                }
            }

            return true;
        }
        catch (Exception ex)
        {
            if (IsWebViewContextUnavailableError(ex))
            {
                _micError = "Device APIs are still initializing. Retrying...";
                return false;
            }

            _mics = Array.Empty<InputMic>();
            _micError = string.IsNullOrWhiteSpace(ex.Message) ? "Failed to load microphone devices." : ex.Message;
            return true;
        }
        finally
        {
            _isLoadingMics = false;
            StateHasChanged();
        }
    }

    private async Task OnChooseCamera(ChangeEventArgs e)
    {
        var selectedCameraId = e.Value?.ToString() ?? string.Empty;
        _selectedCameraId = selectedCameraId;
        await DevicePreferences.SetCameraDeviceId(selectedCameraId, LocalStorage);
    }

    private async Task<bool> RefreshCamerasAsync(bool requestPermission = false)
    {
        _isLoadingCameras = true;
        _cameraError = null;
        StateHasChanged();

        try
        {
            if (requestPermission)
            {
                var granted = await RealtimeKitDeviceService.RequestCameraPermissionAsync();
                if (!granted)
                {
                    _cameraError = "Camera permission was not granted.";
                }
            }

            _cameraPermissionState = await RealtimeKitDeviceService.GetCameraPermissionStateAsync();
            _cameras = await RealtimeKitDeviceService.GetVideoInputDevicesAsync();

            if (_cameras.Length == 0)
            {
                _selectedCameraId = null;

                if (string.Equals(_cameraPermissionState, "denied", StringComparison.OrdinalIgnoreCase))
                {
                    _cameraError ??= "Camera access is blocked. Enable it in browser site settings, then refresh devices.";
                }
            }
            else
            {
                var savedDeviceId = DevicePreferences.CameraDeviceId;
                var hasSavedSelection = !string.IsNullOrWhiteSpace(savedDeviceId)
                    && _cameras.Any(x => x.DeviceId == savedDeviceId);

                if (hasSavedSelection)
                {
                    _selectedCameraId = savedDeviceId;
                }
                else
                {
                    _selectedCameraId = _cameras[0].DeviceId;

                    if (!string.IsNullOrWhiteSpace(_selectedCameraId))
                    {
                        await DevicePreferences.SetCameraDeviceId(_selectedCameraId, LocalStorage);
                    }
                }
            }

            return true;
        }
        catch (Exception ex)
        {
            if (IsWebViewContextUnavailableError(ex))
            {
                _cameraError = "Device APIs are still initializing. Retrying...";
                return false;
            }

            _cameras = Array.Empty<InputMic>();
            _cameraError = string.IsNullOrWhiteSpace(ex.Message) ? "Failed to load camera devices." : ex.Message;
            return true;
        }
        finally
        {
            _isLoadingCameras = false;
            StateHasChanged();
        }
    }

    private static bool IsWebViewContextUnavailableError(Exception ex)
    {
        Exception? current = ex;
        while (current is not null)
        {
            if (!string.IsNullOrWhiteSpace(current.Message)
                && current.Message.Contains(WebViewContextUnavailableMessage, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            current = current.InnerException;
        }

        return false;
    }

    private async Task SwitchAutoEmojis()
    {
        DevicePreferences.AutoEmoji = !DevicePreferences.AutoEmoji;
        await LocalStorage.SetAsync("AutoEmoji", DevicePreferences.AutoEmoji);
        MarkdownManager.RegenPipeline();
    }

    private string GetMicPermissionDescription()
    {
        if (string.Equals(_micPermissionState, "granted", StringComparison.OrdinalIgnoreCase))
            return "Microphone access is enabled for this site.";

        if (string.Equals(_micPermissionState, "denied", StringComparison.OrdinalIgnoreCase))
            return "Microphone access is blocked in your browser.";

        if (string.Equals(_micPermissionState, "prompt", StringComparison.OrdinalIgnoreCase))
            return "Microphone access has not been granted yet.";

        if (string.Equals(_micPermissionState, "unsupported", StringComparison.OrdinalIgnoreCase))
            return "This browser does not support microphone device access for this feature.";

        return "Microphone permission state is unavailable on this browser. Use 'Enable Microphone Access' to request access.";
    }

    private string GetCameraPermissionDescription()
    {
        if (string.Equals(_cameraPermissionState, "granted", StringComparison.OrdinalIgnoreCase))
            return "Camera access is enabled for this site.";

        if (string.Equals(_cameraPermissionState, "denied", StringComparison.OrdinalIgnoreCase))
            return "Camera access is blocked in your browser.";

        if (string.Equals(_cameraPermissionState, "prompt", StringComparison.OrdinalIgnoreCase))
            return "Camera access has not been granted yet.";

        if (string.Equals(_cameraPermissionState, "unsupported", StringComparison.OrdinalIgnoreCase))
            return "This browser does not support camera device access for this feature.";

        return "Camera permission state is unavailable on this browser. Use 'Enable Camera Access' to request access.";
    }

    private async Task LoadErrorReportingStateAsync()
    {
        var response = await Client.PrimaryNode.GetJsonAsync<UserPreferences>("api/users/me/preferences");
        if (response.Success && response.Data is not null)
        {
            _errorReportingEnabled = response.Data.ErrorReportingState == ErrorReportingState.All;
            await DevicePreferences.SetErrorReportingEnabled(_errorReportingEnabled, LocalStorage);
        }
    }

    private async Task OnErrorReportingClick()
    {
        _errorReportingEnabled = !_errorReportingEnabled;
        var state = _errorReportingEnabled ? ErrorReportingState.All : ErrorReportingState.None;
        await Client.PrimaryNode.PostAsync($"api/users/me/preferences/errorReporting/{(int)state}", null);
        await DevicePreferences.SetErrorReportingEnabled(_errorReportingEnabled, LocalStorage);
        StateHasChanged();
    }
}
