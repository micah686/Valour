@inject ValourClient Client
@implements IAsyncDisposable

<RealtimeKitComponent @ref="_rtk" />

<div class="call-panel @((VideoMode ? "video-mode" : "audio-mode"))">
    <div class="call-header">
        <div class="call-header-info">
            <span class="call-channel-name">@ActiveChannel?.Name</span>
        </div>
        <div class="call-status-badge @StatusBadgeClass">
            <span class="call-status-dot"></span>
            <span>@StatusText</span>
        </div>
    </div>

    <div class="call-controls">
        @if (!_joined)
        {
            <button class="call-ctrl-btn reconnect" disabled="@_connecting" @onmousedown="OnClickReconnect" title="Connect">
                <i class="bi bi-arrow-clockwise"></i>
            </button>
        }
        else
        {
            <button class="call-ctrl-btn @(_audioEnabled ? "" : "toggled-danger")" @onmousedown="OnClickMute" title="@(_audioEnabled ? "Mute" : "Unmute")">
                <i class="bi @(_audioEnabled ? "bi-mic-fill" : "bi-mic-mute-fill")"></i>
            </button>
        }

        @if (VideoMode && _joined)
        {
            <button class="call-ctrl-btn @(_videoEnabled ? "" : "toggled-danger")" @onmousedown="OnClickToggleVideo" title="@(_videoEnabled ? "Disable Camera" : "Enable Camera")">
                <i class="bi @(_videoEnabled ? "bi-camera-video-fill" : "bi-camera-video-off-fill")"></i>
            </button>

            <button class="call-ctrl-btn @(_screenShareEnabled ? "toggled" : "")" @onmousedown="OnClickToggleScreenShare" title="@(_screenShareEnabled ? "Stop Sharing Screen" : "Share Screen")">
                <i class="bi @(_screenShareEnabled ? "bi-display-fill" : "bi-display")"></i>
            </button>
        }

        <button class="call-ctrl-btn" @onmousedown="OnClickSettings" title="Settings">
            <i class="bi bi-gear-fill"></i>
        </button>

        <button class="call-ctrl-btn danger" @onmousedown="OnClickLeave" title="Leave Call">
            <i class="bi bi-box-arrow-right"></i>
        </button>
    </div>

    @if (VideoMode)
    {
        <div class="video-stage">
            @if (_joined && _participants.Count == 0)
            {
                <p class="video-empty">Waiting for participants…</p>
            }
            else if (!_joined)
            {
                <p class="video-empty">Join the call to start video.</p>
            }
            else
            {
                
                var videoTiles = BuildVideoTiles();
                
                if (GetFocusedVideoTile(videoTiles) is { } focusedVideoTile)
                {
                    <div class="video-focus-layout">
                        <div class="video-focus-main">
                            @RenderVideoTile(new VideoTileRenderModel(focusedVideoTile.Participant, focusedVideoTile.Source, true, false))
                        </div>
                        <div class="video-focus-strip">
                            @foreach (var videoTile in GetThumbnailVideoTiles(videoTiles, focusedVideoTile.TileKey))
                            {
                                @RenderVideoTile(new VideoTileRenderModel(videoTile.Participant, videoTile.Source, false, true))
                            }
                        </div>
                    </div>
                }
                else
                {
                    <div class="video-grid @GetVideoGridClass(videoTiles.Count)">
                        @foreach (var videoTile in videoTiles)
                        {
                            @RenderVideoTile(new VideoTileRenderModel(videoTile.Participant, videoTile.Source, false, false))
                        }
                    </div>
                }

                <div class="video-audio-hosts">
                    @foreach (var participant in _participants)
                    {
                        <audio id="@GetParticipantAudioElementId(participant.PeerId)" class="participant-audio" autoplay playsinline></audio>
                    }
                </div>
            }
        </div>

        @if (_joined && GetFullscreenVideoTile(BuildVideoTiles()) is { } fullscreenVideoTile)
        {
            <div class="video-fullscreen-backdrop" @onmousedown="CloseViewportFullscreen">
                <div class="video-fullscreen-shell" @onmousedown:stopPropagation="true">
                    @RenderVideoTile(new VideoTileRenderModel(
                        fullscreenVideoTile.Participant,
                        fullscreenVideoTile.Source,
                        false,
                        false,
                        true))

                    <button class="video-fullscreen-close"
                            @onmousedown="CloseViewportFullscreen"
                            title="Exit Fullscreen">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            </div>
        }
    }
    else if (_joined)
    {
        <div class="call-participants">
            <div class="call-participants-header">
                <span class="call-participants-label">Participants</span>
                <span class="call-participants-count">@_participants.Count</span>
            </div>

            @if (_participants.Count == 0)
            {
                <p class="call-participants-empty">No one else is here yet.</p>
            }
            else
            {
                @foreach (var participant in _participants)
                {
                    <div class="@GetParticipantClass(participant)" @key="participant.PeerId">
                        <div class="participant-info">
                            @if (GetParticipantMember(participant.UserId) is { } participantMember)
                            {
                                <UserInfoComponent Member="@participantMember" Style="width: 100%;" />
                            }
                            else
                            {
                                <UserInfoComponent UserId="@participant.UserId" Style="width: 100%;" />
                            }
                        </div>
                        @if (participant.IsSelf)
                        {
                            @if (!_audioEnabled)
                            {
                                <span class="participant-self-muted" title="You are muted">
                                    <i class="bi bi-mic-mute-fill"></i>
                                </span>
                            }
                        }
                        else
                        {
                            
                            var participantVolume = GetParticipantVolume(participant.PeerId);
                            var participantVolumeMuted = participantVolume == 0;
                            var moderatorMuted = IsParticipantModeratorMuted(participant);
                        
                            <div class="participant-volume">
                                <input type="range" min="0" max="100"
                                       value="@participantVolume"
                                       @oninput="(e) => OnParticipantVolumeChanged(participant.PeerId, e)"
                                       class="participant-volume-slider" />
                                <button class="participant-volume-btn @(participantVolumeMuted ? "muted" : "")"
                                        @onmousedown="() => ToggleParticipantMute(participant.PeerId)"
                                        title="@(participantVolumeMuted ? "Unmute" : "Mute")">
                                    <i class="bi @GetVolumeIcon(participantVolume)"></i>
                                </button>
                            </div>

                            @if ((_canMuteParticipants || _canKickParticipants) && participant.UserId > 0)
                            {
                                <div class="participant-moderation">
                                    @if (_canMuteParticipants)
                                    {
                                        <button class="participant-mod-btn warn @(moderatorMuted ? "toggled" : "")"
                                                @onmousedown="() => OnClickToggleMuteParticipant(participant)"
                                                title="@(moderatorMuted ? "Unmute participant" : "Mute participant")">
                                            <i class="bi @(moderatorMuted ? "bi-mic-fill" : "bi-mic-mute-fill")"></i>
                                        </button>
                                    }
                                    @if (_canKickParticipants)
                                    {
                                        <button class="participant-mod-btn danger"
                                                @onmousedown="() => OnClickKickParticipant(participant)"
                                                title="Kick from call">
                                            <i class="bi bi-door-open-fill"></i>
                                        </button>
                                    }
                                </div>
                            }
                        }
                        <audio id="@GetParticipantAudioElementId(participant.PeerId)" class="participant-audio" autoplay playsinline></audio>
                    </div>
                }
            }
        </div>
    }

    @if (!string.IsNullOrWhiteSpace(_error))
    {
        <div class="call-error">
            <i class="bi bi-exclamation-triangle-fill"></i>
            <span>@_error</span>
        </div>
    }
</div>

@code {
    [CascadingParameter]
    public ModalRoot? ModalRoot { get; set; }

    [Parameter]
    public Channel? Channel { get; set; }

    [Parameter]
    public bool VideoMode { get; set; }

    [Parameter]
    public EventCallback OnLeaveRequested { get; set; }

    private RealtimeKitComponent? _rtk;
    private readonly SemaphoreSlim _joinLock = new(1, 1);
    private static readonly TimeSpan TokenRequestTimeout = TimeSpan.FromSeconds(12);
    private static readonly TimeSpan PermissionRequestTimeout = TimeSpan.FromSeconds(8);
    private static readonly TimeSpan ResetTimeout = TimeSpan.FromSeconds(4);
    private static readonly TimeSpan ParticipantSnapshotTimeout = TimeSpan.FromSeconds(3);
    private static readonly TimeSpan StopParticipantRefreshWaitTimeout = TimeSpan.FromSeconds(2);
    private static readonly TimeSpan JoinTimeout = TimeSpan.FromSeconds(25);
    private static readonly TimeSpan LeaveTimeout = TimeSpan.FromSeconds(8);
    private readonly string _voiceSessionId = Guid.NewGuid().ToString("N");
    private readonly object _memberPrefetchLock = new();

    private bool _joined;
    private bool _connecting;

    private bool _audioEnabled = true;
    private bool _videoEnabled;
    private bool _screenShareEnabled;

    private string? _error;
    private bool _pendingParticipantMediaSync;
    private Dictionary<string, int> _participantVolumes = new();
    private List<VoiceParticipantState> _participants = new();
    private CancellationTokenSource? _participantRefreshLoopCts;
    private Task? _participantRefreshLoopTask;
    private int _participantRefreshInProgress;
    private readonly HashSet<long> _participantMemberPrefetchInFlight = new();
    private IDisposable? _voiceSessionReplaceSubscription;
    private IDisposable? _voiceModerationSubscription;

    private bool _canMuteParticipants;
    private bool _canKickParticipants;
    private readonly HashSet<long> _moderatorMutedParticipantUserIds = new();
    private string? _focusedVideoTileKey;
    private string? _fullscreenVideoTileKey;

    public Channel? ActiveChannel { get; private set; }

    private string StatusText => _connecting ? "Connecting" : _joined ? "Connected" : "Disconnected";
    private string StatusBadgeClass => _connecting ? "connecting" : _joined ? "connected" : "disconnected";

    private int GetParticipantVolume(string peerId) =>
        _participantVolumes.TryGetValue(peerId, out var vol) ? vol : 100;

    private static string GetVolumeIcon(int volume) => volume switch
    {
        0 => "bi-volume-mute-fill",
        <= 50 => "bi-volume-down-fill",
        _ => "bi-volume-up-fill"
    };

    private RenderFragment RenderVideoTile(VideoTileRenderModel model) => @<div class="@GetVideoTileClass(model.Participant, model.Source, model.IsFocusedMain, model.IsThumbnail, model.IsViewportFullscreen)" @key="model.RenderKey">
        <video id="@GetParticipantVideoElementId(model.Participant.PeerId, model.Source, model.IsViewportFullscreen)" class="participant-video" autoplay playsinline muted></video>

        @if (!HasVisualTrackForTile(model))
        {
            <div class="video-fallback">
                @if (model.IsScreenShareTile)
                {
                    <i class="bi bi-display-fill screen-share-fallback-icon"></i>
                }
                else
                {
                    <div class="video-fallback-avatar"
                         style="@GetParticipantAvatarStyle(model.Participant)"
                         title="@model.Participant.DisplayName">
                    </div>
                }
            </div>
        }

        <div class="video-overlay">
            <div class="video-participant-meta">
                @if (GetParticipantMember(model.Participant.UserId) is { } overlayParticipantMember)
                {
                    <UserInfoComponent Member="@overlayParticipantMember" Style="width: 100%;" />
                }
                else
                {
                    <UserInfoComponent UserId="@model.Participant.UserId" Style="width: 100%;" />
                }
            </div>

            <div class="video-overlay-actions">
                @if (model.Participant.IsSelf)
                {
                    <span class="participant-self-muted @(_audioEnabled ? "hidden" : "")" title="You are muted">
                        <i class="bi bi-mic-mute-fill"></i>
                    </span>
                }
                else
                {
                    
                    var participantVolume = GetParticipantVolume(model.Participant.PeerId);
                    var participantVolumeMuted = participantVolume == 0;
                    var moderatorMuted = IsParticipantModeratorMuted(model.Participant);
                
                    <div class="video-tile-controls">
                        <input type="range" min="0" max="100"
                               value="@participantVolume"
                               @oninput="(e) => OnParticipantVolumeChanged(model.Participant.PeerId, e)"
                               class="participant-volume-slider" />
                        <button class="participant-volume-btn @(participantVolumeMuted ? "muted" : "")"
                                @onmousedown="() => ToggleParticipantMute(model.Participant.PeerId)"
                                title="@(participantVolumeMuted ? "Unmute" : "Mute")">
                            <i class="bi @GetVolumeIcon(participantVolume)"></i>
                        </button>

                        @if ((_canMuteParticipants || _canKickParticipants) && model.Participant.UserId > 0)
                        {
                            @if (_canMuteParticipants)
                            {
                                <button class="participant-mod-btn warn @(moderatorMuted ? "toggled" : "")"
                                        @onmousedown="() => OnClickToggleMuteParticipant(model.Participant)"
                                        title="@(moderatorMuted ? "Unmute participant" : "Mute participant")">
                                    <i class="bi @(moderatorMuted ? "bi-mic-fill" : "bi-mic-mute-fill")"></i>
                                </button>
                            }
                            @if (_canKickParticipants)
                            {
                                <button class="participant-mod-btn danger"
                                        @onmousedown="() => OnClickKickParticipant(model.Participant)"
                                        title="Kick from call">
                                    <i class="bi bi-door-open-fill"></i>
                                </button>
                            }
                        }
                    </div>
                }

                <button class="video-focus-btn @(model.IsFocusedMain ? "active" : "")"
                        @onmousedown:stopPropagation="true"
                        @onmousedown="() => ToggleFocusedVideoTile(model.TileKey)"
                        title="@(model.IsFocusedMain ? "Exit focused view" : "Focus participant")">
                    <i class="bi @(model.IsFocusedMain ? "bi-fullscreen-exit" : "bi-arrows-fullscreen")"></i>
                </button>

                <button class="video-viewport-btn @(IsFullscreenVideoTile(model.TileKey) ? "active" : "")"
                        @onmousedown:stopPropagation="true"
                        @onmousedown="() => ToggleViewportFullscreen(model.TileKey)"
                        title="@(IsFullscreenVideoTile(model.TileKey) ? "Exit full screen" : "Full screen (95%)")">
                    <i class="bi @(IsFullscreenVideoTile(model.TileKey) ? "bi-fullscreen-exit" : "bi-arrows-angle-expand")"></i>
                </button>
            </div>
        </div>
    </div>;

    protected override void OnInitialized()
    {
        DevicePreferences.OnMicrophoneDeviceIdChanged += OnMicrophoneSelected;
        DevicePreferences.OnCameraDeviceIdChanged += OnCameraSelected;
        BrowserUtils.Focused += OnAppResumed;
        SubscribeToVoiceHubEvents();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Channel is not null)
        {
            await Initialize(Channel);
        }

        if (!_pendingParticipantMediaSync || !_joined || _rtk is null)
            return;

        _pendingParticipantMediaSync = false;

        try
        {
            await SyncParticipantMediaElementsAsync();
        }
        catch (Exception ex)
        {
            _error = GetExceptionMessage(ex, "Failed to sync participant media.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private void SubscribeToVoiceHubEvents()
    {
        var hub = Client.PrimaryNode?.HubConnection;
        if (hub is null)
            return;

        _voiceSessionReplaceSubscription?.Dispose();
        _voiceSessionReplaceSubscription = hub.On<VoiceSessionReplaceEvent>(
            "Voice-Session-Replace",
            OnVoiceSessionReplace);

        _voiceModerationSubscription?.Dispose();
        _voiceModerationSubscription = hub.On<VoiceModerationEvent>(
            "Voice-Moderation-Action",
            OnVoiceModerationAction);
    }

    private async Task Initialize(Channel channel)
    {
        SubscribeToVoiceHubEvents();

        if (!ISharedChannel.VoiceChannelTypes.Contains(channel.ChannelType))
            return;

        if (_rtk is null)
        {
            _error = "Voice system is still loading. Try again.";
            StateHasChanged();
            return;
        }

        await _joinLock.WaitAsync();

        try
        {
            _error = null;
            ActiveChannel = channel;
            await RefreshModerationPermissionsAsync(channel);
            _connecting = true;
            StateHasChanged();

            if (_joined)
            {
                await SafeLeaveRoomInternalAsync(clearChannel: false);
            }

            var tokenResult = await Client.PrimaryNode.PostAsyncWithResponse<RealtimeKitVoiceTokenResponse>(
                    $"api/voice/realtimekit/token/{channel.Id}?sessionId={Uri.EscapeDataString(_voiceSessionId)}")
                .WaitAsync(TokenRequestTimeout);

            if (!tokenResult.Success || tokenResult.Data is null || string.IsNullOrWhiteSpace(tokenResult.Data.AuthToken))
            {
                _error = string.IsNullOrWhiteSpace(tokenResult.Message)
                    ? "Failed to fetch a voice token from the server."
                    : tokenResult.Message;
                _connecting = false;
                StateHasChanged();
                return;
            }

            await _rtk.InitializeAsync(new RealtimeKitInitOptions
            {
                AuthToken = tokenResult.Data.AuthToken,
                BaseUri = "realtime.cloudflare.com",
                Defaults = new RealtimeKitMediaDefaults
                {
                    Audio = false,
                    Video = false,
                    MediaConfiguration = new RealtimeKitMediaConfiguration
                    {
                        Audio = new RealtimeKitAudioMediaConfiguration
                        {
                            EnableHighBitrate = true,
                            EnableStereo = true
                        },
                        Video = new RealtimeKitVideoMediaConfiguration
                        {
                            Width = new RealtimeKitNumericConstraint
                            {
                                Ideal = 1920
                            },
                            Height = new RealtimeKitNumericConstraint
                            {
                                Ideal = 1080
                            },
                            FrameRate = new RealtimeKitNumericConstraint
                            {
                                Ideal = 60,
                                Max = 60
                            }
                        }
                    }
                },
                Overrides = new RealtimeKitOverrides
                {
                    SimulcastConfig = new RealtimeKitSimulcastConfig
                    {
                        Disable = false,
                        Encodings = VideoMode
                            ? new[]
                            {
                                new RealtimeKitSimulcastEncoding
                                {
                                    Rid = "q",
                                    ScaleResolutionDownBy = 4,
                                    MaxBitrate = 200000,
                                    MaxFramerate = 15,
                                    ScalabilityMode = "L1T1"
                                },
                                new RealtimeKitSimulcastEncoding
                                {
                                    Rid = "h",
                                    ScaleResolutionDownBy = 2,
                                    MaxBitrate = 800000,
                                    MaxFramerate = 30,
                                    ScalabilityMode = "L1T1"
                                },
                                new RealtimeKitSimulcastEncoding
                                {
                                    Rid = "f",
                                    MaxBitrate = 2500000,
                                    MaxFramerate = 60,
                                    ScalabilityMode = "L1T1"
                                }
                            }
                            : null
                    }
                }
            });

            await _rtk.JoinRoomAsync((int)JoinTimeout.TotalMilliseconds);

            _joined = true;
            _connecting = false;

            AppLifecycle.NotifyCallStarted();

            // Attempt to enable microphone — not required to participate
            try
            {
                if (await EnsureMicrophonePermissionAsync())
                {
                    await _rtk.EnableAudioAsync();
                    await SetMic(DevicePreferences.MicrophoneDeviceId);
                }
                else
                {
                    _audioEnabled = false;
                }
            }
            catch
            {
                _audioEnabled = false;
            }

            await RefreshStateFromSdkAsync();
            await RefreshParticipantsAsync();
            StartParticipantRefreshLoop();
        }
        catch (Exception ex)
        {
            _error = GetExceptionMessage(ex, "Failed to connect to voice.");
            _connecting = false;
            await SafeLeaveRoomInternalAsync(clearChannel: false);
        }
        finally
        {
            _joinLock.Release();
            StateHasChanged();
        }
    }

    private async Task RefreshStateFromSdkAsync()
    {
        if (_rtk is null || !_joined)
            return;

        var state = await _rtk.GetSelfStateAsync();
        if (state is null)
            return;

        _audioEnabled = state.AudioEnabled;
        _videoEnabled = state.VideoEnabled;
        _screenShareEnabled = state.ScreenShareEnabled;
    }

    private async Task RefreshModerationPermissionsAsync(Channel channel)
    {
        _canMuteParticipants = false;
        _canKickParticipants = false;

        if (channel.PlanetId is null)
            return;

        try
        {
            var muteTask = channel
                .HasPermissionAsync(Client.Me.Id, VoiceChannelPermissions.MuteMembers)
                .WaitAsync(PermissionRequestTimeout);
            var kickTask = channel
                .HasPermissionAsync(Client.Me.Id, VoiceChannelPermissions.KickMembers)
                .WaitAsync(PermissionRequestTimeout);

            await Task.WhenAll(muteTask, kickTask);
            _canMuteParticipants = muteTask.Result;
            _canKickParticipants = kickTask.Result;
        }
        catch
        {
            _canMuteParticipants = false;
            _canKickParticipants = false;
        }
    }

    private async Task OnMicrophoneSelected(string? id)
    {
        await SetMic(id);
    }

    private async Task OnCameraSelected(string? id)
    {
        await SetCamera(id);
    }

    private async Task OnAppResumed()
    {
        if (!_joined || ActiveChannel is null || _rtk is null)
            return;

        try
        {
            await _rtk.GetSelfStateAsync();
        }
        catch
        {
            await InvokeAsync(async () =>
            {
                var channel = ActiveChannel;
                if (channel is not null)
                    await Initialize(channel);
            });
        }
    }

    private void OnVoiceSessionReplace(VoiceSessionReplaceEvent update)
    {
        if (update is null)
            return;

        if (string.Equals(update.SessionId, _voiceSessionId, StringComparison.Ordinal))
            return;

        _ = InvokeAsync(async () =>
        {
            if (ActiveChannel is null || ActiveChannel.Id != update.ChannelId)
                return;

            if (!_joined && !_connecting)
                return;

            _error = "Disconnected because this account joined this call from another instance.";
            await SafeLeaveRoomInternalAsync(clearChannel: false);
            StateHasChanged();
        });
    }

    private void OnVoiceModerationAction(VoiceModerationEvent update)
    {
        if (update is null)
            return;

        _ = InvokeAsync(async () =>
        {
            if (ActiveChannel is null || ActiveChannel.Id != update.ChannelId)
                return;

            if (!_joined && !_connecting)
                return;

            switch (update.Action)
            {
                case VoiceModerationActionType.Mute:
                    if (_rtk is not null && _joined && _audioEnabled)
                    {
                        try
                        {
                            await _rtk.DisableAudioAsync();
                            await RefreshStateFromSdkAsync();
                        }
                        catch
                        {
                            // Ignore client-side mute failures from remote moderation commands.
                        }
                    }
                    break;
                case VoiceModerationActionType.Unmute:
                    if (_rtk is not null && _joined && !_audioEnabled)
                    {
                        try
                        {
                            await _rtk.EnableAudioAsync();
                            await SetMic(DevicePreferences.MicrophoneDeviceId);
                            await RefreshStateFromSdkAsync();
                        }
                        catch
                        {
                            // Ignore client-side unmute failures from remote moderation commands.
                        }
                    }
                    break;
                case VoiceModerationActionType.Kick:
                    _error = "You were removed from this call.";
                    await SafeLeaveRoomInternalAsync(clearChannel: false);
                    break;
            }

            StateHasChanged();
        });
    }

    private async Task OnClickReconnect()
    {
        if (ActiveChannel is null)
            return;

        await Initialize(ActiveChannel);
    }

    private async Task OnClickMute()
    {
        if (_rtk is null || !_joined)
            return;

        try
        {
            if (_audioEnabled)
            {
                await _rtk.DisableAudioAsync();
            }
            else
            {
                if (!await EnsureMicrophonePermissionAsync())
                {
                    StateHasChanged();
                    return;
                }

                await _rtk.EnableAudioAsync();
                await SetMic(DevicePreferences.MicrophoneDeviceId);
            }

            await RefreshStateFromSdkAsync();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }

        StateHasChanged();
    }

    private async Task OnClickToggleVideo()
    {
        if (_rtk is null || !_joined)
            return;

        try
        {
            if (_videoEnabled)
            {
                await _rtk.DisableVideoAsync();
            }
            else
            {
                if (!await EnsureCameraPermissionAsync())
                {
                    StateHasChanged();
                    return;
                }

                await _rtk.EnableVideoAsync();
                await SetCamera(DevicePreferences.CameraDeviceId);
            }

            await RefreshStateFromSdkAsync();
            _pendingParticipantMediaSync = true;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }

        StateHasChanged();
    }

    private async Task OnClickToggleScreenShare()
    {
        if (_rtk is null || !_joined || !VideoMode)
            return;

        try
        {
            if (_screenShareEnabled)
            {
                await _rtk.DisableScreenShareAsync();
            }
            else
            {
                if (!await _rtk.IsScreenShareSupportedAsync())
                {
                    _error = "Screen sharing is not supported on this browser/device.";
                    StateHasChanged();
                    return;
                }

                await _rtk.EnableScreenShareAsync();
            }

            await RefreshStateFromSdkAsync();
            _pendingParticipantMediaSync = true;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }

        StateHasChanged();
    }

    private Task OnClickToggleMuteParticipant(VoiceParticipantState participant) =>
        SendVoiceModerationActionAsync(
            participant,
            IsParticipantModeratorMuted(participant) ? "unmute" : "mute");

    private Task OnClickKickParticipant(VoiceParticipantState participant) =>
        SendVoiceModerationActionAsync(participant, "kick");

    private async Task SendVoiceModerationActionAsync(VoiceParticipantState participant, string action)
    {
        if (ActiveChannel is null || participant.IsSelf || participant.UserId <= 0)
            return;

        if (action == "mute" && !_canMuteParticipants)
            return;

        if (action == "kick" && !_canKickParticipants)
            return;

        var result = await Client.PrimaryNode.PostAsync(
            $"api/voice/realtimekit/channels/{ActiveChannel.Id}/participants/{participant.UserId}/{action}",
            new { });

        if (!result.Success)
        {
            _error = string.IsNullOrWhiteSpace(result.Message)
                ? $"Failed to {action} participant."
                : result.Message;
            StateHasChanged();
            return;
        }

        if (participant.UserId > 0)
        {
            if (action == "mute")
                _moderatorMutedParticipantUserIds.Add(participant.UserId);
            else if (action is "unmute" or "kick")
                _moderatorMutedParticipantUserIds.Remove(participant.UserId);
        }

        _error = null;
        StateHasChanged();
    }

    private void OnClickSettings()
    {
        if (ModalRoot is null)
            return;

        var data = new EditUserComponent.ModalParams
        {
            User = Client.Me,
            StartCategory = "General Settings",
            StartItem = "Device Preferences"
        };

        ModalRoot.OpenModal<EditUserComponent>(data);
    }

    private async Task OnClickLeave()
    {
        await LeaveRoom();

        if (OnLeaveRequested.HasDelegate)
            await OnLeaveRequested.InvokeAsync();
    }

    private async Task LeaveRoom()
    {
        await SafeLeaveRoomInternalAsync(clearChannel: true);
    }

    private async Task SafeLeaveRoomInternalAsync(bool clearChannel)
    {
        if (_rtk is not null)
        {
            try
            {
                if (_joined)
                {
                    await _rtk.LeaveRoomAsync().WaitAsync(LeaveTimeout);
                }
                else
                {
                    await _rtk.ResetAsync().WaitAsync(ResetTimeout);
                }
            }
            catch
            {
                // Ignore leave failures during teardown.
            }
        }

        await StopParticipantRefreshLoopAsync();

        _joined = false;
        _connecting = false;
        _audioEnabled = true;
        _videoEnabled = false;
        _screenShareEnabled = false;
        _participantVolumes = new Dictionary<string, int>();
        _participants = new List<VoiceParticipantState>();
        _focusedVideoTileKey = null;
        _fullscreenVideoTileKey = null;
        _canMuteParticipants = false;
        _canKickParticipants = false;
        _moderatorMutedParticipantUserIds.Clear();
        _pendingParticipantMediaSync = false;
        lock (_memberPrefetchLock)
        {
            _participantMemberPrefetchInFlight.Clear();
        }

        AppLifecycle.NotifyCallEnded();

        if (clearChannel)
        {
            ActiveChannel = null;
            _error = null;
        }
    }

    private async Task SetMic(string? deviceId)
    {
        if (_rtk is null || !_joined || string.IsNullOrWhiteSpace(deviceId))
            return;

        try
        {
            await _rtk.SetDeviceAsync(new RealtimeKitDeviceSelection
            {
                DeviceId = deviceId,
                Kind = "audioinput"
            });

            await RefreshStateFromSdkAsync();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task SetCamera(string? deviceId)
    {
        if (_rtk is null || !_joined || string.IsNullOrWhiteSpace(deviceId))
            return;

        try
        {
            await _rtk.SetDeviceAsync(new RealtimeKitDeviceSelection
            {
                DeviceId = deviceId,
                Kind = "videoinput"
            });

            await RefreshStateFromSdkAsync();
            _pendingParticipantMediaSync = true;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task<bool> EnsureMicrophonePermissionAsync()
    {
        if (_rtk is null)
            return false;

        try
        {
            var permissionState = await _rtk.GetMicrophonePermissionStateAsync();
            if (string.Equals(permissionState, "denied", StringComparison.OrdinalIgnoreCase))
            {
                _error = "Microphone access is blocked. Enable it in browser site settings.";
                return false;
            }

            if (string.Equals(permissionState, "unsupported", StringComparison.OrdinalIgnoreCase))
            {
                _error = "Microphone access is not supported on this browser/device.";
                return false;
            }

            if (string.Equals(permissionState, "granted", StringComparison.OrdinalIgnoreCase))
                return true;

            var granted = await _rtk.RequestMicrophonePermissionAsync();
            if (!granted)
            {
                _error = "Microphone permission was not granted.";
            }
            else
            {
                _error = null;
            }

            return granted;
        }
        catch
        {
            // If permission APIs are unavailable, continue and let SDK attempt capture directly.
            return true;
        }
    }

    private async Task<bool> EnsureCameraPermissionAsync()
    {
        if (_rtk is null)
            return false;

        try
        {
            var permissionState = await _rtk.GetCameraPermissionStateAsync();
            if (string.Equals(permissionState, "denied", StringComparison.OrdinalIgnoreCase))
            {
                _error = "Camera access is blocked. Enable it in browser site settings.";
                return false;
            }

            if (string.Equals(permissionState, "unsupported", StringComparison.OrdinalIgnoreCase))
            {
                _error = "Camera access is not supported on this browser/device.";
                return false;
            }

            if (string.Equals(permissionState, "granted", StringComparison.OrdinalIgnoreCase))
                return true;

            var granted = await _rtk.RequestPlatformVideoPermissionAsync();
            if (!granted)
            {
                _error = "Camera permission was not granted.";
            }
            else
            {
                _error = null;
            }

            return granted;
        }
        catch
        {
            // If permission APIs are unavailable, continue and let SDK attempt capture directly.
            return true;
        }
    }

    private async Task SyncParticipantMediaElementsAsync()
    {
        if (_rtk is null)
            return;

        var videoTiles = VideoMode ? BuildVideoTiles() : null;

        foreach (var participant in _participants)
        {
            if (string.IsNullOrWhiteSpace(participant.PeerId))
                continue;

            var volume = GetParticipantVolume(participant.PeerId) / 100.0;
            await _rtk.SyncParticipantAudioAsync(
                GetParticipantAudioElementId(participant.PeerId),
                participant.PeerId,
                volume);
        }

        if (!VideoMode || videoTiles is null)
            return;

        foreach (var videoTile in videoTiles)
        {
            await _rtk.SyncParticipantVideoAsync(
                GetParticipantVideoElementId(videoTile.Participant.PeerId, videoTile.Source, false),
                videoTile.Participant.PeerId,
                preferScreenShare: videoTile.PreferScreenShare);
        }

        if (GetFullscreenVideoTile(videoTiles) is { } fullscreenVideoTile)
        {
            await _rtk.SyncParticipantVideoAsync(
                GetParticipantVideoElementId(fullscreenVideoTile.Participant.PeerId, fullscreenVideoTile.Source, true),
                fullscreenVideoTile.Participant.PeerId,
                preferScreenShare: fullscreenVideoTile.PreferScreenShare);
        }
    }

    private Task ToggleParticipantMute(string peerId)
    {
        var current = GetParticipantVolume(peerId);
        _participantVolumes[peerId] = current == 0 ? 100 : 0;
        _pendingParticipantMediaSync = true;
        StateHasChanged();
        return Task.CompletedTask;
    }

    private Task OnParticipantVolumeChanged(string peerId, ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out var volume))
        {
            _participantVolumes[peerId] = Math.Clamp(volume, 0, 100);
            _pendingParticipantMediaSync = true;
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    private async Task RefreshParticipantsAsync()
    {
        if (_rtk is null || !_joined)
            return;

        if (Interlocked.Exchange(ref _participantRefreshInProgress, 1) == 1)
            return;

        try
        {
            var snapshot = await _rtk.GetParticipantsSnapshotAsync().WaitAsync(ParticipantSnapshotTimeout);
            var nextParticipants = BuildParticipantState(snapshot);
            QueueMissingParticipantMemberFetches(nextParticipants);

            if (AreParticipantsEqual(_participants, nextParticipants))
                return;

            _participants = nextParticipants;
            var nextVideoTiles = BuildVideoTiles(nextParticipants);

            if (!string.IsNullOrWhiteSpace(_focusedVideoTileKey) &&
                !nextVideoTiles.Any(x =>
                    string.Equals(x.TileKey, _focusedVideoTileKey, StringComparison.Ordinal)))
            {
                _focusedVideoTileKey = null;
            }

            if (!string.IsNullOrWhiteSpace(_fullscreenVideoTileKey) &&
                !nextVideoTiles.Any(x =>
                    string.Equals(x.TileKey, _fullscreenVideoTileKey, StringComparison.Ordinal)))
            {
                _fullscreenVideoTileKey = null;
            }
            _pendingParticipantMediaSync = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = GetExceptionMessage(ex, "Failed to refresh call participants.");
        }
        finally
        {
            Interlocked.Exchange(ref _participantRefreshInProgress, 0);
        }
    }

    private void StartParticipantRefreshLoop()
    {
        if (_participantRefreshLoopTask is { IsCompleted: false })
            return;

        _participantRefreshLoopCts?.Dispose();
        _participantRefreshLoopCts = new CancellationTokenSource();
        var cancellationToken = _participantRefreshLoopCts.Token;

        _participantRefreshLoopTask = Task.Run(async () =>
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    await RefreshParticipantsAsync();
                    await Task.Delay(350, cancellationToken);
                }
                catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
                {
                    break;
                }
                catch
                {
                    // Keep the participant refresh loop alive across transient SDK failures.
                }
            }
        }, cancellationToken);
    }

    private async Task StopParticipantRefreshLoopAsync()
    {
        if (_participantRefreshLoopCts is null)
            return;

        var cts = _participantRefreshLoopCts;
        var refreshTask = _participantRefreshLoopTask;

        _participantRefreshLoopCts = null;
        _participantRefreshLoopTask = null;

        try
        {
            cts.Cancel();
            if (refreshTask is not null)
            {
                await refreshTask.WaitAsync(StopParticipantRefreshWaitTimeout);
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when stopping the refresh loop.
        }
        catch (TimeoutException)
        {
            // If a refresh iteration is blocked in JS interop, don't block teardown forever.
        }
        finally
        {
            cts.Dispose();
        }
    }

    private static string GetParticipantClass(VoiceParticipantState participant)
    {
        return participant.IsActiveSpeaker
            ? "voice-participant active-speaker"
            : "voice-participant";
    }

    private static string GetVideoTileClass(
        VoiceParticipantState participant,
        VideoTileSource source,
        bool isFocusedMain,
        bool isThumbnail,
        bool isViewportFullscreen)
    {
        var css = "video-tile";
        if (participant.IsActiveSpeaker)
            css += " active-speaker";
        if (participant.IsSelf)
            css += " self";
        if (source == VideoTileSource.ScreenShare)
            css += " screen-share";
        if (isFocusedMain)
            css += " focus-main";
        if (isThumbnail)
            css += " focus-thumb";
        if (isViewportFullscreen)
            css += " viewport-fullscreen";
        return css;
    }

    private List<VideoTileRenderModel> BuildVideoTiles() => BuildVideoTiles(_participants);

    private static List<VideoTileRenderModel> BuildVideoTiles(IReadOnlyList<VoiceParticipantState> participants)
    {
        var tiles = new List<VideoTileRenderModel>(participants.Count * 2);
        foreach (var participant in participants)
        {
            if (participant.ScreenShareEnabled || participant.HasScreenShareTrack)
            {
                tiles.Add(new VideoTileRenderModel(participant, VideoTileSource.ScreenShare, false, false));
            }

            tiles.Add(new VideoTileRenderModel(participant, VideoTileSource.Camera, false, false));
        }

        return tiles;
    }

    private VideoTileRenderModel? GetFocusedVideoTile(IReadOnlyList<VideoTileRenderModel> videoTiles)
    {
        if (string.IsNullOrWhiteSpace(_focusedVideoTileKey))
            return null;

        return videoTiles.FirstOrDefault(x =>
            string.Equals(x.TileKey, _focusedVideoTileKey, StringComparison.Ordinal));
    }

    private VideoTileRenderModel? GetFullscreenVideoTile(IReadOnlyList<VideoTileRenderModel> videoTiles)
    {
        if (string.IsNullOrWhiteSpace(_fullscreenVideoTileKey))
            return null;

        return videoTiles.FirstOrDefault(x =>
            string.Equals(x.TileKey, _fullscreenVideoTileKey, StringComparison.Ordinal));
    }

    private static IEnumerable<VideoTileRenderModel> GetThumbnailVideoTiles(
        IReadOnlyList<VideoTileRenderModel> videoTiles,
        string focusedTileKey)
    {
        if (string.IsNullOrWhiteSpace(focusedTileKey))
            return videoTiles;

        return videoTiles.Where(x =>
            !string.Equals(x.TileKey, focusedTileKey, StringComparison.Ordinal));
    }

    private void ToggleFocusedVideoTile(string tileKey)
    {
        if (string.IsNullOrWhiteSpace(tileKey))
            return;

        _focusedVideoTileKey = string.Equals(_focusedVideoTileKey, tileKey, StringComparison.Ordinal)
            ? null
            : tileKey;

        // The focused layout moves/recreates video elements; force a rebind so
        // the enlarged tile does not render with a detached/empty stream.
        _pendingParticipantMediaSync = true;
    }

    private bool IsFullscreenVideoTile(string tileKey) =>
        !string.IsNullOrWhiteSpace(tileKey)
        && string.Equals(_fullscreenVideoTileKey, tileKey, StringComparison.Ordinal);

    private void ToggleViewportFullscreen(string tileKey)
    {
        if (string.IsNullOrWhiteSpace(tileKey))
            return;

        _fullscreenVideoTileKey = IsFullscreenVideoTile(tileKey)
            ? null
            : tileKey;

        _pendingParticipantMediaSync = true;
    }

    private void CloseViewportFullscreen()
    {
        if (string.IsNullOrWhiteSpace(_fullscreenVideoTileKey))
            return;

        _fullscreenVideoTileKey = null;
        _pendingParticipantMediaSync = true;
    }

    private static bool HasVisualTrackForTile(VideoTileRenderModel model)
    {
        return model.Source == VideoTileSource.ScreenShare
            ? model.Participant.HasScreenShareTrack
            : model.Participant.VideoEnabled && model.Participant.HasVideoTrack;
    }

    private string GetParticipantAvatarStyle(VoiceParticipantState participant)
    {
        var avatar = GetParticipantMember(participant.UserId)?.GetAvatar() ?? ISharedUser.DefaultAvatar;
        return $"background-image: url('{avatar}');";
    }

    private static string GetVideoGridClass(int tileCount)
    {
        var count = Math.Max(1, tileCount);
        if (count <= 1)
            return "one";
        if (count == 2)
            return "two";
        if (count <= 4)
            return "four";
        if (count <= 6)
            return "six";

        return "many";
    }

    private static string GetParticipantAudioElementId(string peerId)
    {
        var normalizedPeerId = string.IsNullOrWhiteSpace(peerId) ? "unknown" : peerId;
        var idBytes = System.Text.Encoding.UTF8.GetBytes(normalizedPeerId);
        var idSuffix = Convert.ToHexString(idBytes).ToLowerInvariant();
        return $"call-audio-{idSuffix}";
    }

    private static string GetParticipantVideoElementId(string peerId, VideoTileSource source, bool isViewportFullscreen)
    {
        var normalizedPeerId = string.IsNullOrWhiteSpace(peerId) ? "unknown" : peerId;
        var idBytes = System.Text.Encoding.UTF8.GetBytes(normalizedPeerId);
        var idSuffix = Convert.ToHexString(idBytes).ToLowerInvariant();
        var sourceSuffix = source == VideoTileSource.ScreenShare ? "screen" : "camera";
        var hostSuffix = isViewportFullscreen ? "fullscreen" : "inline";
        return $"call-video-{sourceSuffix}-{hostSuffix}-{idSuffix}";
    }

    private PlanetMember? GetParticipantMember(long userId)
    {
        if (userId <= 0 || ActiveChannel?.PlanetId is null || ActiveChannel.Planet is null)
            return null;

        var key = new PlanetMemberKey(userId, ActiveChannel.PlanetId.Value);
        if (!Client.Cache.MemberKeyToId.TryGetValue(key, out var memberId))
            return null;

        if (!ActiveChannel.Planet.Members.TryGet(memberId, out var member))
            return null;

        return member;
    }

    private bool IsParticipantModeratorMuted(VoiceParticipantState participant) =>
        participant.UserId > 0 && _moderatorMutedParticipantUserIds.Contains(participant.UserId);

    private void QueueMissingParticipantMemberFetches(IReadOnlyList<VoiceParticipantState> participants)
    {
        if (ActiveChannel?.PlanetId is null || ActiveChannel.Planet is null || participants.Count == 0)
            return;

        foreach (var userId in participants.Select(x => x.UserId).Where(x => x > 0).Distinct())
        {
            if (GetParticipantMember(userId) is not null)
                continue;

            bool added;
            lock (_memberPrefetchLock)
            {
                added = _participantMemberPrefetchInFlight.Add(userId);
            }

            if (!added)
                continue;

            _ = FetchParticipantMemberAsync(userId);
        }
    }

    private async Task FetchParticipantMemberAsync(long userId)
    {
        try
        {
            var activeChannel = ActiveChannel;
            if (activeChannel?.Planet is null)
                return;

            await activeChannel.Planet.FetchMemberByUserAsync(userId);
        }
        catch
        {
            // Ignore lookup failures; user fallback rendering remains available.
        }
        finally
        {
            lock (_memberPrefetchLock)
            {
                _participantMemberPrefetchInFlight.Remove(userId);
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private List<VoiceParticipantState> BuildParticipantState(RealtimeKitParticipantsSnapshot? snapshot)
    {
        if (snapshot?.Participants is null || snapshot.Participants.Length == 0)
            return new List<VoiceParticipantState>();

        var activeSpeakerPeerId = snapshot.ActiveSpeakerPeerId;

        return snapshot.Participants
            .Where(x => !string.IsNullOrWhiteSpace(x.PeerId))
            .Select(x => new VoiceParticipantState
            {
                PeerId = x.PeerId!,
                UserId = ResolveUserId(x),
                DisplayName = string.IsNullOrWhiteSpace(x.Name) ? "Unknown Participant" : x.Name,
                AudioEnabled = x.AudioEnabled,
                VideoEnabled = x.VideoEnabled,
                ScreenShareEnabled = x.ScreenShareEnabled,
                HasAudioTrack = x.HasAudioTrack,
                AudioTrackId = x.AudioTrackId,
                HasVideoTrack = x.HasVideoTrack,
                VideoTrackId = x.VideoTrackId,
                HasScreenShareTrack = x.HasScreenShareTrack,
                ScreenShareTrackId = x.ScreenShareTrackId,
                IsSelf = x.IsSelf,
                IsActiveSpeaker = string.Equals(x.PeerId, activeSpeakerPeerId, StringComparison.Ordinal)
            })
            .OrderByDescending(x => x.IsSelf)
            .ThenBy(x => x.DisplayName, StringComparer.OrdinalIgnoreCase)
            .ToList();
    }

    private static long ResolveUserId(RealtimeKitParticipantState participant)
    {
        if (TryParseUserId(participant.CustomParticipantId, out var customId))
            return customId;

        if (long.TryParse(participant.UserId, out var userId) && userId > 0)
            return userId;

        return 0;
    }

    private static bool TryParseUserId(string? source, out long userId)
    {
        userId = 0;
        if (string.IsNullOrWhiteSpace(source))
            return false;

        var delimiterIndex = source.IndexOf(':');
        var candidate = delimiterIndex > 0 ? source[..delimiterIndex] : source;
        return long.TryParse(candidate, out userId) && userId > 0;
    }

    private static bool AreParticipantsEqual(IReadOnlyList<VoiceParticipantState> current, IReadOnlyList<VoiceParticipantState> next)
    {
        if (current.Count != next.Count)
            return false;

        for (int i = 0; i < current.Count; i++)
        {
            var left = current[i];
            var right = next[i];

            if (!string.Equals(left.PeerId, right.PeerId, StringComparison.Ordinal))
                return false;

            if (left.UserId != right.UserId)
                return false;

            if (!string.Equals(left.DisplayName, right.DisplayName, StringComparison.Ordinal))
                return false;

            if (left.AudioEnabled != right.AudioEnabled
                || left.VideoEnabled != right.VideoEnabled
                || left.ScreenShareEnabled != right.ScreenShareEnabled
                || left.HasAudioTrack != right.HasAudioTrack
                || !string.Equals(left.AudioTrackId, right.AudioTrackId, StringComparison.Ordinal)
                || left.HasVideoTrack != right.HasVideoTrack
                || !string.Equals(left.VideoTrackId, right.VideoTrackId, StringComparison.Ordinal)
                || left.HasScreenShareTrack != right.HasScreenShareTrack
                || !string.Equals(left.ScreenShareTrackId, right.ScreenShareTrackId, StringComparison.Ordinal)
                || left.IsSelf != right.IsSelf
                || left.IsActiveSpeaker != right.IsActiveSpeaker)
            {
                return false;
            }
        }

        return true;
    }

    private sealed record VideoTileRenderModel(
        VoiceParticipantState Participant,
        VideoTileSource Source,
        bool IsFocusedMain,
        bool IsThumbnail,
        bool IsViewportFullscreen = false)
    {
        public string TileKey => $"{Participant.PeerId}:{(Source == VideoTileSource.ScreenShare ? "screen" : "camera")}";
        public string RenderKey => IsViewportFullscreen ? $"{TileKey}:fullscreen" : TileKey;
        public bool PreferScreenShare => Source == VideoTileSource.ScreenShare;
        public bool IsScreenShareTile => Source == VideoTileSource.ScreenShare;
    }

    private enum VideoTileSource
    {
        Camera,
        ScreenShare
    }

    private sealed class VoiceParticipantState
    {
        public string PeerId { get; init; } = string.Empty;
        public long UserId { get; init; }
        public string DisplayName { get; init; } = "Unknown Participant";
        public bool AudioEnabled { get; init; }
        public bool VideoEnabled { get; init; }
        public bool ScreenShareEnabled { get; init; }
        public bool HasAudioTrack { get; init; }
        public string? AudioTrackId { get; init; }
        public bool HasVideoTrack { get; init; }
        public string? VideoTrackId { get; init; }
        public bool HasScreenShareTrack { get; init; }
        public string? ScreenShareTrackId { get; init; }
        public bool IsSelf { get; init; }
        public bool IsActiveSpeaker { get; init; }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        DevicePreferences.OnMicrophoneDeviceIdChanged -= OnMicrophoneSelected;
        DevicePreferences.OnCameraDeviceIdChanged -= OnCameraSelected;
        BrowserUtils.Focused -= OnAppResumed;
        _voiceSessionReplaceSubscription?.Dispose();
        _voiceSessionReplaceSubscription = null;
        _voiceModerationSubscription?.Dispose();
        _voiceModerationSubscription = null;

        await SafeLeaveRoomInternalAsync(clearChannel: true);
    }

    private static string GetExceptionMessage(Exception exception, string fallbackMessage)
    {
        if (!string.IsNullOrWhiteSpace(exception.Message))
            return exception.Message;

        if (exception.InnerException is not null && !string.IsNullOrWhiteSpace(exception.InnerException.Message))
            return exception.InnerException.Message;

        return fallbackMessage;
    }
}
